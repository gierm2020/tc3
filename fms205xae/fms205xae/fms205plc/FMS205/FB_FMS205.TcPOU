<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_FMS205" Id="{a261f573-1402-443e-9bab-e88e0bf02070}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_FMS205 EXTENDS FB_Module_Base
VAR_INPUT
	ManiobrasDeseadas: UINT :=1; // POST15 AÑADIDO VALOR POR DEFECTO
END_VAR

VAR_OUTPUT
	
	ManiobrasRealizadas: UINT := 0;
	ManiobrasPendientes: UINT;
	
	// IC: 		BOOL := FALSE; 	// todos los módulos están en condiciones iniciales
    Preparada : BOOL := TRUE;	// la estación está preparada después de encender
	FinCiclo: 	BOOL := FALSE;	// una pieza se ha completado
	FinTarea: 	BOOL := FALSE;	// el lote se ha completado
	Fallo: 		BOOL := FALSE;	// al menos un módulo ha fallado
    Finalizada: BOOL := TRUE;	// la estación está lista para apagarse    	
END_VAR

VAR
	gm					: S_GEMMA; 		// Información sobre la familia y modo GEMMA en que se encuentra la estación
	td					: S_TestData; 	// Consignas relacionadas con el modo de pruebas

	// controladores de la máquina, la función de producción y la guía GEMMA
	fbPanel					: FB_Panel;
	// fbDirector				: FB_Director;
	ctInp 					: S_ControllerInput := (tm := tm);
	
	// módulos de la FMS205
	mdAlime			: FB_Alimentador			(ID:=0, Name:='Alimentador'); // MRT:=tm.MaximoTiempoRespuesta,
	mdCarga 	: FB_Alimentador(ID:=0,Name:='Alimentador');//: FB_PickAndPlace			(ID:=1, Name:='Carga'); // MRT:=tm.MaximoTiempoRespuesta,
	mdMedid		: FB_Alimentador(ID:=0,Name:='Alimentador');//	: FB_MedidorTapa			(ID:=3, Name:='Medidor'); // MRT:=tm.MaximoTiempoRespuesta,
	mdInduc: FB_Alimentador(ID:=0,Name:='Alimentador');// 	: FB_CaptadorInductivo		(ID:=4, Name:='Inductivo'); // MRT:=tm.MaximoTiempoRespuesta,
	mdFotoe: FB_Alimentador(ID:=0,Name:='Alimentador');// : FB_DetectorFotoelectrico	(ID:=5, Name:='Fotoeléctrico'); // MRT:=tm.MaximoTiempoRespuesta,
	mdEvacu: FB_Alimentador(ID:=0,Name:='Alimentador');//			 	: FB_Evacuador				(ID:=7, Name:='Evacuador'); // MRT:=tm.MaximoTiempoRespuesta,
	mdDesca: FB_Alimentador(ID:=0,Name:='Alimentador');// 	: FB_PickAndPlace			(ID:=8, Name:='Descarga'); // MRT:=tm.MaximoTiempoRespuesta,
	mdPlato: FB_Alimentador(ID:=0,Name:='Alimentador');//			: FB_PlatoDivisor			(ID:=9, Name:='Plato'); // MRT:=tm.MaximoTiempoRespuesta,
	mdCinta: FB_Alimentador(ID:=0,Name:='Alimentador');//					: FB_Cinta					(ID:=10, Name:='Cinta'); // MRT:=tm.MaximoTiempoRespuesta,
	//fbFMS205_SFC			: FB_FMS205_SFC;
	fbFMS205_Producir_SFC	: FB_FMS205_SFC;

	

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbPanel();


IC := InitialConditions(); // comprueba si todos los módulos cumplen las condiciones iniciales	
	
Preparada := TRUE; // PENDIENTE SI LA ESTACIÓN NECESITA UNA SECUENCIA DE PREPARACIÓN 


FinCiclo := 		(* Todos los módulos han terminado su parte del ciclo *)
	mdAlime.Done AND
	//mdCarga.ctOut.Done AND
	//mdMedid.ctOut.Done AND
	//mdInduc.ctOut.Done AND
	//mdFotoe.ctOut.Done AND
	//mdEvacu.ctOut.Done AND
	//mdDesca.ctOut.Done AND
	//mdPlato.ctOut.Done AND
	mdCinta.Done;

IF FinCiclo THEN	
	// Todos los módulos han terminado su secuencia de producir
	// TODO SÓLO SE PUEDE CONTAR UNA TAPA HECHA SI NO SE HA RECHAZADO Y SI SE HA METIDO EN EL CARRO
	ManiobrasRealizadas := ManiobrasRealizadas + 1;
	// POAST15  ManiobrasPendientes := ManiobrasDeseadas - ManiobrasRealizadas;	
	// Añadir aquí LA LÓGICA DEL FINAL DE CICLO
	// p. ej. actualización del plato con los resultados de sensores  	
END_IF
ManiobrasPendientes := ManiobrasDeseadas - ManiobrasRealizadas; // POST15 hay que calcular siempre las maniobras pendientes

FinTarea := ManiobrasPendientes = 0; 	// Se finaliza la tarea si no quedan maniobras pendientes

Fallo:=									// La estaciónn está en fallo si al menos un módulo ha fallado
	mdAlime.Failure OR
	//mdCarga.ctOut.Fail OR
	//mdMedid.ctOut.Fail OR 
	//mdInduc.ctOut.Fail OR
	//mdFotoe.ctOut.Fail OR
	//mdEvacu.ctOut.Fail OR
	//mdDesca.ctOut.Fail OR
	mdCinta.Failure; 

	
Finalizada := TRUE;	 // PENDIENTE SI LA ESTACIÓN NECESITA UNA SECUENCIA DE PREPARACIÓN 

Director();
(*
fbDirector(
	fbPanel 	:= fbPanel,
	IC 			:= IC, 
	Preparada 	:= Preparada,
	FinCiclo	:= FinCiclo,
	FinTarea	:= FinTarea,
	Fallo		:= Fallo,
	Finalizada	:= Finalizada);
*)

// IF fbDirector.Modo = E_Gemma.A6Inicializando THEN


// Informar la estructura ctInp que se copiará a todos y cada uno de los controladores
ctInp.ModeAct	:= gm.ModeActual;
ctInp.ModePre	:= gm.ModePrev;

ctInp.Execute :=  (* El coordinador indica que hay empezar *)
	(gm.ModeActual = E_GEMMA.F6Probando AND td.Execute) OR
	(gm.ModeActual <> E_GEMMA.F6Probando AND
		(
			(gm.ModeActual = E_GEMMA.A2ParaFinCiclo) OR 
	 		(gm.ModeActual = E_GEMMA.A3ParadaEstado) OR 
	 	 	(gm.ModeActual = E_GEMMA.F1ProduccionNormal) OR 
	 	 	(gm.ModeActual = E_GEMMA.F2SecuenciaPreparacion) OR 
	 	 	(gm.ModeActual = E_GEMMA.F3SecuenciaFinalizacion) OR 
	 	 	(gm.ModeActual = E_GEMMA.F5VerificacionOrdenada) OR 
	 	 	(gm.ModeActual = E_GEMMA.F6Probando) OR 
	 	 	(gm.ModeActual = E_GEMMA.D3ProducirConFallos)
		) 
	);
		

ctInp.Ack := // Notificar a los módulos que ya pueden volver al inicio
	(gm.ModeActual = E_GEMMA.F6Probando AND td.Ack) OR 
	(gm.ModeActual <> E_GEMMA.F6Probando AND FinCiclo);
// TODO SI HAY FIN DE CICLO HAY QUE HACER UN MONTÓN DE COSAS, POR EJEMPLO, ACTUALIZAR EL PLATO CON EL SENSOR FOTOELÉCTRICO

ctInp.Manual := (* Establece modo de funcionamiento manual *) 
	(gm.ModeActual = E_GEMMA.F4VerificacionSinOrden);
	
ctInp.Pause := (* Pausa la ejecucion de la funcionalidad  *)
	(gm.ModeActual = E_GEMMA.A3ParadaEstado) OR 
	(gm.ModeActual = E_GEMMA.A4ParadaObtenida) OR 
	(gm.ModeActual = E_GEMMA.A5PreparandoTrasFallo) OR 
	(gm.ModeActual = E_GEMMA.D1ParadaEmergencia) OR 
	(gm.ModeActual = E_GEMMA.D2TratamientoFallos);

ctInp.Reset := (* Restablece la condicion de fallo *)
    (gm.ModeActual = E_GEMMA.A5PreparandoTrasFallo);

ctInp.Restart := (* Reinicia el estado del controlador *)
	(gm.ModeActual = E_GEMMA.A6Inicializando);

ctInp.Restore := (* Restaura las condiciones iniciales (referencia) *)
    (gm.ModeActual=E_GEMMA.A6Inicializando); 

ctInp.Resume := (* Continua la ejecucion de la funcionalidad en curso *)
	(FALSE);
	
ctInp.Safe := (* Condicion de seguridad para iniciar una funcionalidad *)
	(TRUE);

	
// copiar la estructura ctInp en todos los módulos para distribuir la misma información de entrada
//mdAlime.ctInp 			:= ctInp;
//mdCarga.ctInp 		:= ctInp;
//mdMedid.ctInp 			:= ctInp;
//mdInduc.ctInp 		:= ctInp;
//mdFotoe.ctInp 	:= ctInp;
//mdEvacu.ctInp 				:= ctInp;
//mdDesca.ctInp 	:= ctInp;
//mdPlato.ctInp 			:= ctInp;

//mdEvacu.Evacuar := TRUE; // TODO PENDIENTE DECISIÓN DE EVACUAR O NO EN FUNCIÓN DEL TIPO DE TAPA
//mdCarga.Mover := TRUE;
//mdDesca.Mover := TRUE;

// TODO CARGA Y DESCARGA TENGAN UNA OPCION DE NO HACER NADA

IF gm.ModeActual = E_GEMMA.F6Probando THEN
	F6TestingMode();
ELSE
	fbFMS205_Producir_SFC(
	//	ctInp					:= ctInp, // POST15
		mdAlime 			:= mdAlime,
		mdCarga 	:= mdCarga,
		mdMedid			:= mdMedid,
		mdInduc 	:= mdInduc,
		mdFotoe := mdFotoe,
		mdEvacu			 	:= mdEvacu,
		mdDesca 	:= mdDesca,
		mdPlato			:= mdPlato
	);
	mdAlime.ModuleProcessCycle();
	//mdCarga.ModuleProcessCycle();
	//mdMedid.ModuleProcessCycle();
	//mdInduc.ModuleProcessCycle();
	//mdFotoe.ModuleProcessCycle();
	//mdEvacu.ModuleProcessCycle();
	//mdDesca.ModuleProcessCycle();
	//mdPlato.ModuleProcessCycle();
END_IF

]]></ST>
    </Implementation>
    <Method Name="Director" Id="{607386c6-63f2-4de2-a057-037fe1b8c79f}">
      <Declaration><![CDATA[METHOD Director : BOOL
// Actualiza el estado de la estación siguiendo el estándar definido la guía GEMMA]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* FUNCION DE ESTADO *)


IF fbPanel.Emergencia THEN
    gm.ModeActual := E_GEMMA.D1ParadaEmergencia;
	
	
ELSIF fbPanel.Reinicia THEN
    gm.ModeActual := E_GEMMA.A6Inicializando;

ELSIF fbPanel.Probando AND gm.ModeActual <> E_GEMMA.F6Probando THEN
	gm.ModePrev := gm.ModeActual; 			// guardamos el modo en que estaba la máquiina antes de entrar a modo pruebas
	gm.ModeActual := E_GEMMA.F6Probando; 	// y pasamos al modo pruebas 

ELSIF gm.ModeActual = E_GEMMA.F6Probando AND NOT fbPanel.Probando THEN
	gm.ModeActual := gm.ModePrev; 			// restauramos el modo en que estaba la máquina antes de pasar a modo pruebas
    // Previo := E_GEMMA.F6Probando;		// y el modo previo queda a F6 DUDAS


ELSE
    CASE gm.ModeActual OF
		
	
        (* ------------------------------------------------------------ Procedimientos de parada *)
		
        E_GEMMA.A1ParadaInicial: (* Parada en el estado inicial *)
            IF NOT InitialConditions() THEN // IF NOT Restaurada THEN
                gm.ModeActual := E_GEMMA.A6Inicializando;
            ELSIF fbPanel.Manual THEN
                gm.ModeActual := E_GEMMA.F4VerificacionSinOrden;
            ELSIF fbPanel.Marcha AND IC THEN  // ELSIF Marcha THEN
                gm.ModeActual := E_GEMMA.F2SecuenciaPreparacion;
			ELSE
				; // Esperar a que se pulse el bortón de marcha
            END_IF
			
        E_GEMMA.A2ParaFinCiclo: (* Parada solicitada a final de ciclo *)
            IF Fallo THEN
                gm.ModePrev := E_GEMMA.A2ParaFinCiclo;
                gm.ModeActual := E_GEMMA.D2TratamientoFallos;
            ELSIF FinCiclo THEN
                gm.ModeActual := E_GEMMA.A1ParadaInicial;
            ELSE
                // Seguir produciendo hasta final de ciclo
                ;
            END_IF
			
        E_GEMMA.A3ParadaEstado: (* Parada solicitada en un estado determinado *)
            ; // estado no tratado en la FMS205 DUDAS
			
        E_GEMMA.A4ParadaObtenida: (* Parada obtenida *)
            ; // estado no tratado en la FMS205 DUDAS
        
		E_GEMMA.A5PreparandoTrasFallo: (* Preparando de reanudacion tras el fallo *)
            IF fbPanel.Marcha THEN // Continua
                gm.ModeActual := gm.ModePrev;
            ELSIF fbPanel.Para THEN // Cancela
                gm.ModeActual := E_GEMMA.A6Inicializando;
				gm.ModePrev := gm.ModeActual; // DUDAS
            END_IF
			
        E_GEMMA.A6Inicializando: (* Situando la PO en el estado inicial *)
            IF IC THEN // Restaurada
                gm.ModeActual := E_GEMMA.A1ParadaInicial;
            ELSIF fbPanel.Manual THEN
                gm.ModeActual := E_GEMMA.F4VerificacionSinOrden;
            END_IF
			
        E_GEMMA.A7SituandoEstado: (* Situando la PO en un estado determinado *)
            ; // estado no tratado en la FMS205

			
			
        (* ------------------------------------------------------------ Procedimientos de funcionamiento *)
        
		E_GEMMA.F1ProduccionNormal: (* Produccion normal *)
            IF Fallo THEN
                gm.ModePrev := E_GEMMA.F1ProduccionNormal; // DUDAS E_GEMMA.A2ParaFinCiclo; //!!! Creo que está mal, no debería ser F1?
                gm.ModeActual := E_GEMMA.D2TratamientoFallos;
            ELSIF FinTarea THEN
                gm.ModeActual := E_GEMMA.F3SecuenciaFinalizacion;
            ELSIF fbPanel.Para THEN
                gm.ModeActual := E_GEMMA.A2ParaFinCiclo;
            END_IF
			
        E_GEMMA.F2SecuenciaPreparacion: (* Secuencia de preparacion *)
            IF Preparada THEN
                gm.ModeActual := E_GEMMA.F1ProduccionNormal;
            ELSE
                // continuar con la secuencia de preparación hasta que esté preparada o haya un error
                ;
            END_IF
			
        E_GEMMA.F3SecuenciaFinalizacion: (* Secuencia de finalizacion *)
            IF Finalizada THEN
                gm.ModeActual := E_GEMMA.A1ParadaInicial;
            ELSE
                // continuar con la secuencia de finalización hasta que esté finalizada o haya un error
                ;
            END_IF
			
        E_GEMMA.F4VerificacionSinOrden: (* Verificacion sin orden *)
            IF Fallo THEN
                gm.ModePrev := E_GEMMA.F4VerificacionSinOrden; // DUDAS E_GEMMA.A2ParaFinCiclo; //!!! Creo que está mal, no debería ser F4?
                gm.ModeActual := E_GEMMA.D2TratamientoFallos;
            ELSIF NOT fbPanel.Manual THEN
				gm.ModeActual := E_GEMMA.A6Inicializando; // después del modo manual, volver a inicializar
            ELSE
                // Seguir en modo manual hasta que halla un fallo o se vuelva al modo automático
                ;
            END_IF
			
        E_GEMMA.F5VerificacionOrdenada: (* Verificacion en orden *)
            ; // estado no tratado en la FMS205
			
        E_GEMMA.F6Probando: (* Prueba *)
            ; // estado no tratado en la FMS205

			
			
        (* ------------------------------------------------------------ Procedimientos de defecto *)
        E_GEMMA.D1ParadaEmergencia: (* Parada de emergencia *)
            IF NOT fbPanel.Emergencia THEN
                gm.ModeActual := E_GEMMA.A6Inicializando; // Al quitar la parada de emergencia hay que reinicializar la estación
            ELSE
                // Esperar a que se quite la parada de emergencia
                ;
            END_IF
			
        E_GEMMA.D2TratamientoFallos: (* Diagnostico/tratamiento de los fallos *)
            IF NOT Fallo THEN
                gm.ModeActual := E_GEMMA.A5PreparandoTrasFallo;
            ELSE
                // Esperar a que se resuelva el fallo
                ;
            END_IF

        E_GEMMA.D3ProducirConFallos: (* Produccion a pesar de los fallos *)
            ; // estado no tratado en la FMS205

    END_CASE
END_IF

(* PARAMETROS DE SALIDA *)
gm.FamiArret  := (gm.ModeActual >= E_GEMMA.A1ParadaInicial) AND 
				 (gm.ModeActual <= E_GEMMA.A7SituandoEstado);
gm.FamiFonct  := (gm.ModeActual >= E_GEMMA.F1ProduccionNormal) AND 
				 (gm.ModeActual <= E_GEMMA.F6Probando);
gm.FamiDefail := (gm.ModeActual >= E_GEMMA.D1ParadaEmergencia) AND 
				 (gm.ModeActual <= E_GEMMA.D3ProducirConFallos);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="F6TestingMode" Id="{697643b6-2262-4b9f-9ecb-336a91083aa9}">
      <Declaration><![CDATA[METHOD F6TestingMode : BOOL

]]></Declaration>
      <Implementation>
        <ST><![CDATA[// en el modo pruebas el control de la fms205 lo hacemos desde la visualización de pruebas
	//ctInp.Execute 	:= fbPanel.ProbarExecute;
	//ctInp.Ack 		:= fbPanel.ProbarAck;

// Cambiar el estado de los sensores cuando hay un flanco positivo del control de cambio de estado de sensores
td.FlancoNegar(CLK := td.Negar);
IF td.FlancoNegar.Q THEN
	mdAlime.NegarSensores();
	//mdCarga.NegarSensores();
	//mdMedid.NegarSensores();
	//mdFotoe.NegarSensores();
	//mdInduc.NegarSensores();
	//mdEvacu.NegarSensores();
	//mdDesca.NegarSensores();
	mdCinta.NegarSensores();
END_IF

mdAlime.Execute := td.Execute AND td.Alime;

// Ejecutar los módulos que se pidan
IF td.Alime THEN
	mdAlime.ModuleProcessCycle();	
END_IF
(*
IF td.Carga THEN
	mdCarga.ModuleProcessCycle();	
END_IF

IF td.Medid THEN
	mdMedid.ModuleProcessCycle();	
END_IF

IF td.Fotoe THEN
	mdFotoe.ModuleProcessCycle();	
END_IF

IF td.Induc THEN
	mdInduc.ModuleProcessCycle();	
END_IF

IF td.Evacu THEN
	mdEvacu.ModuleProcessCycle();	
END_IF

IF td.Desca THEN
	mdDesca.ModuleProcessCycle();	
END_IF

IF td.Plato THEN
	mdPlato.ModuleProcessCycle();	
END_IF
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="InitialConditions" Id="{ced68a35-410b-4233-b292-485a89563ec3}">
      <Declaration><![CDATA[METHOD InitialConditions : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* La estación está en condiciones iniciales si cada módulo lo está *)
InitialConditions :=			
	mdAlime.InitialConditions() AND
	//mdCarga.InitialConditions() AND
	//mdMedid.InitialConditions() AND 
	//mdInduc.InitialConditions() AND
	//mdFotoe.InitialConditions() AND
	//mdEvacu.InitialConditions() AND
	//mdDesca.InitialConditions() AND
	mdCinta.InitialConditions();
 
	// OR (fbDirector.Modo=E_GEMMA.F6Probando); // POST15 PARA FORZAR CONDICIONES INICIALES SIN HARDWARE !!! eliminar
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>