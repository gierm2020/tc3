<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_FMS205" Id="{a261f573-1402-443e-9bab-e88e0bf02070}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_FMS205
VAR_INPUT
	IC: 		BOOL := FALSE; 	// todos los módulos están en condiciones iniciales
    Execute: BOOL;
	Ack : BOOL;
END_VAR
VAR_OUTPUT
	Ready: BOOL;
	Failure: BOOL;
	Done: BOOL;	
END_VAR	
VAR_INPUT
	MaximoTiempoRespuesta: TIME := T#5S;
	ManiobrasDeseadas: UINT :=1; // POST15 AÑADIDO VALOR POR DEFECTO
END_VAR

VAR_OUTPUT
	ManiobrasRealizadas: UINT := 0;
	ManiobrasPendientes: UINT;
	
	Preparada : BOOL := TRUE;	// la estación está preparada después de encender
	FinCiclo: 	BOOL := FALSE;	// una pieza se ha completado
	FinTarea: 	BOOL := FALSE;	// el lote se ha completado
	Fallo: 		BOOL := FALSE;	// al menos un módulo ha fallado
    Finalizada: BOOL := TRUE;	// la estación está lista para apagarse    	
END_VAR

VAR
	// controladores de la máquina, la función de producción y la guía GEMMA 
	td						: S_TestData;
	//tm					: S_Timeouts;
	tm: FB_Timelimits 		;// := (Speed:=10.0); //S_Timeouts;
	gm						: S_Gemma := (ModeActual:= E_GEMMA.A6Inicializando, ModePrev := E_GEMMA.A6Inicializando);
	dr						: FB_Director;
	
	// módulos de la FMS205
	mdAlimentador			: FB_Alimentador			:= (ID := 1, tm := tm, gm := gm, Name := 'Alimentador');
	mdPickAndPlaceCarga 	: FB_PickAndPlace			:= (ID := 2, tm := tm, gm := gm, Name := 'Carga');
	mdMedidorTapa			: FB_MedidorTapa			:= (ID := 3, tm := tm, gm := gm, Name := 'Medidor');
	mdCaptadorInductivo 	: FB_CaptadorInductivo		:= (ID := 4, tm := tm, gm := gm, Name :=  'Inductivo');
	mdDetectorFotoelectrico : FB_DetectorFotoelectrico	:= (ID := 5, tm := tm, gm := gm, Name :=  'Fotoeléctrico');
	mdEvacuador			 	: FB_Evacuador				:= (ID := 6, tm := tm, gm := gm, Name :=  'Evacuador');
	mdPickAndPlaceDescarga 	: FB_PickAndPlace			:= (ID := 7, tm := tm, gm := gm, Name :=  'Descarga');
	mdPlatoDivisor			: FB_PlatoDivisor			:= (ID := 8, tm := tm, gm := gm, Name :=  'Plato');
	
	fbPanel					: FB_Panel := (gm := gm);
	
	//ctInp 					: S_ControllerInput;
	
	
	//fbFMS205_SFC			: FB_FMS205_SFC;
	fbFMS205_Producir_SFC	: FB_FMS205_SFC;

	

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[dr.ProcessCycle(
	IC := TRUE, // InitialConditions()
	Fallo := FALSE,
	FinCiclo := FALSE,
	FinTarea := FALSE,
	Preparada  := TRUE,
	Finalizada := TRUE);

IF dr.bot_Funcion THEN
	F5VerificacionOrdenada();
ELSIF dr.bot_Empezar THEN
	F1ProduccionNormal();
ELSE
	fbPanel(gm:=gm);
	IC:=InitialConditions();
	Preparada := TRUE; // PENDIENTE SI LA ESTACIÓN NECESITA UNA SECUENCIA DE PREPARACIÓN 
	
	
	FinCiclo := 		(* Todos los módulos han terminado su parte del ciclo *)
		mdAlimentador.Done AND
		mdPickAndPlaceCarga.Done AND
		mdMedidorTapa.Done AND
		mdCaptadorInductivo.Done AND
		mdDetectorFotoelectrico.Done AND
		mdEvacuador.Done AND
		mdPickAndPlaceDescarga.Done AND
		mdPlatoDivisor.Done;
	
	IF FinCiclo THEN	
		// Todos los módulos han terminado su secuencia de producir
		// TODO SÓLO SE PUEDE CONTAR UNA TAPA HECHA SI NO SE HA RECHAZADO Y SI SE HA METIDO EN EL CARRO
		ManiobrasRealizadas := ManiobrasRealizadas + 1;
		// POAST15  ManiobrasPendientes := ManiobrasDeseadas - ManiobrasRealizadas;	
		// Añadir aquí LA LÓGICA DEL FINAL DE CICLO
		// p. ej. actualización del plato con los resultados de sensores  	
	END_IF
	ManiobrasPendientes := ManiobrasDeseadas - ManiobrasRealizadas; // POST15 hay que calcular siempre las maniobras pendientes
	
	FinTarea := ManiobrasPendientes = 0; 	// Se finaliza la tarea si no quedan maniobras pendientes
	
	Fallo:=									// La estaciónn está en fallo si al menos un módulo ha fallado
		mdAlimentador.Failure OR
		mdPickAndPlaceCarga.Failure OR
		mdMedidorTapa.Failure OR 
		mdCaptadorInductivo.Failure OR
		mdDetectorFotoelectrico.Failure OR
		mdEvacuador.Failure OR
		mdPickAndPlaceDescarga.Failure; 
	
		
	Finalizada := TRUE;	 // PENDIENTE SI LA ESTACIÓN NECESITA UNA SECUENCIA DE PREPARACIÓN 
	Director();
	
	Execute :=  (* El coordinador indica que hay empezar *)
		(gm.ModeActual = E_GEMMA.F6Probando AND dr.bot_Ejecutar) OR // td.Execute) OR
		(gm.ModeActual <> E_GEMMA.F6Probando AND
			(
				(gm.ModeActual = E_GEMMA.A2ParaFinCiclo) OR 
				(gm.ModeActual = E_GEMMA.A3ParadaEstado) OR 
				(gm.ModeActual = E_GEMMA.F1ProduccionNormal) OR 
				(gm.ModeActual = E_GEMMA.F2SecuenciaPreparacion) OR 
				(gm.ModeActual = E_GEMMA.F3SecuenciaFinalizacion) OR 
				(gm.ModeActual = E_GEMMA.F5VerificacionOrdenada) OR 
				(gm.ModeActual = E_GEMMA.F6Probando) OR 
				(gm.ModeActual = E_GEMMA.D3ProducirConFallos)
			) 
		);
			
	
	Ack := // Notificar a los módulos que ya pueden volver al inicio
		(gm.ModeActual = E_GEMMA.F6Probando AND dr.bot_Continuar) OR 
		(gm.ModeActual <> E_GEMMA.F6Probando AND FinCiclo);
	// TODO SI HAY FIN DE CICLO HAY QUE HACER UN MONTÓN DE COSAS, POR EJEMPLO, ACTUALIZAR EL PLATO CON EL SENSOR FOTOELÉCTRICO
	
	
	mdEvacuador.Evacuar := TRUE; // TODO PENDIENTE DECISIÓN DE EVACUAR O NO EN FUNCIÓN DEL TIPO DE TAPA
	mdPickAndPlaceCarga.Mover := TRUE;
	mdPickAndPlaceDescarga.Mover := TRUE;
	
	// TODO CARGA Y DESCARGA TENGAN UNA OPCION DE NO HACER NADA
	
	IF dr.ModeActual = E_GEMMA.F5VerificacionOrdenada THEN //IF gm.ModeActual = E_GEMMA.F6Probando THEN
		TestControl();
	ELSE
		fbFMS205_Producir_SFC(		
			mdAlimentador 			:= mdAlimentador,
			mdPickAndPlaceCarga 	:= mdPickAndPlaceCarga,
			mdMedidorTapa			:= mdMedidorTapa,
			mdCaptadorInductivo 	:= mdCaptadorInductivo,
			mdDetectorFotoelectrico := mdDetectorFotoelectrico,
			mdEvacuador			 	:= mdEvacuador,
			mdPickAndPlaceDescarga 	:= mdPickAndPlaceDescarga,
			mdPlatoDivisor			:= mdPlatoDivisor,
			IC:=IC, Execute:=Execute, Ack:=Ack,
			Ready=>Ready, Done=>Done, Failure=>Failure);
	
	END_IF
	
END_IF
ProcessCycle();

]]></ST>
    </Implementation>
    <Method Name="Director" Id="{18e5528e-3d47-4a5a-a3f0-e60a169bf51a}">
      <Declaration><![CDATA[METHOD Director : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* FUNCION DE ESTADO *)


IF fbPanel.cn.Emergencia THEN
    gm.ModeActual := E_GEMMA.D1ParadaEmergencia;
	
	
ELSIF fbPanel.cn.Reinicia THEN
    gm.ModeActual := E_GEMMA.A6Inicializando;

ELSIF fbPanel.cn.Pruebas AND gm.ModeActual <> E_GEMMA.F6Probando THEN
	gm.ModePrev := gm.ModeActual; 			// guardamos el modo en que estaba la máquiina antes de entrar a modo pruebas
	gm.ModeActual := E_GEMMA.F6Probando; 	// y pasamos al modo pruebas 

ELSIF gm.ModeActual = E_GEMMA.F6Probando AND NOT fbPanel.cn.Pruebas THEN
	gm.ModeActual := gm.ModePrev; 			// restauramos el modo en que estaba la máquina antes de pasar a modo pruebas
    // Previo := E_GEMMA.F6Probando;		// y el modo previo queda a F6 DUDAS


ELSE
    CASE gm.ModeActual OF
		
	
        (* ------------------------------------------------------------ Procedimientos de parada *)
		
        E_GEMMA.A1ParadaInicial: (* Parada en el estado inicial *)
            IF NOT InitialConditions() THEN // IF NOT Restaurada THEN
                gm.ModeActual := E_GEMMA.A6Inicializando;
            ELSIF fbPanel.cn.Manual THEN
                gm.ModeActual := E_GEMMA.F4VerificacionSinOrden;
            ELSIF fbPanel.cn.Marcha AND IC THEN  // ELSIF Marcha THEN
                gm.ModeActual := E_GEMMA.F2SecuenciaPreparacion;
			ELSE
				; // Esperar a que se pulse el bortón de marcha
            END_IF
			
        E_GEMMA.A2ParaFinCiclo: (* Parada solicitada a final de ciclo *)
            IF Fallo THEN
                gm.ModePrev := E_GEMMA.A2ParaFinCiclo;
                gm.ModeActual := E_GEMMA.D2TratamientoFallos;
            ELSIF FinCiclo THEN
                gm.ModeActual := E_GEMMA.A1ParadaInicial;
            ELSE
                // Seguir produciendo hasta final de ciclo
                ;
            END_IF
			
        E_GEMMA.A3ParadaEstado: (* Parada solicitada en un estado determinado *)
            ; // estado no tratado en la FMS205 DUDAS
			
        E_GEMMA.A4ParadaObtenida: (* Parada obtenida *)
            ; // estado no tratado en la FMS205 DUDAS
        
		E_GEMMA.A5PreparandoTrasFallo: (* Preparando de reanudacion tras el fallo *)
            IF fbPanel.cn.Marcha THEN // Continua
                gm.ModeActual := gm.ModePrev;
            ELSIF fbPanel.cn.Para THEN // Cancela
                gm.ModeActual := E_GEMMA.A6Inicializando;
				gm.ModePrev := gm.ModeActual; // DUDAS
            END_IF
			
        E_GEMMA.A6Inicializando: (* Situando la PO en el estado inicial *)
            IF IC THEN // Restaurada
                gm.ModeActual := E_GEMMA.A1ParadaInicial;
            ELSIF fbPanel.cn.Manual THEN
                gm.ModeActual := E_GEMMA.F4VerificacionSinOrden;
            END_IF
			
        E_GEMMA.A7SituandoEstado: (* Situando la PO en un estado determinado *)
            ; // estado no tratado en la FMS205

			
			
        (* ------------------------------------------------------------ Procedimientos de funcionamiento *)
        
		E_GEMMA.F1ProduccionNormal: (* Produccion normal *)
            IF Fallo THEN
                gm.ModePrev := E_GEMMA.F1ProduccionNormal; // DUDAS E_GEMMA.A2ParaFinCiclo; //!!! Creo que está mal, no debería ser F1?
                gm.ModeActual := E_GEMMA.D2TratamientoFallos;
            ELSIF FinTarea THEN
                gm.ModeActual := E_GEMMA.F3SecuenciaFinalizacion;
            ELSIF fbPanel.cn.Para THEN
                gm.ModeActual := E_GEMMA.A2ParaFinCiclo;
            END_IF
			
        E_GEMMA.F2SecuenciaPreparacion: (* Secuencia de preparacion *)
            IF Preparada THEN
                gm.ModeActual := E_GEMMA.F1ProduccionNormal;
            ELSE
                // continuar con la secuencia de preparación hasta que esté preparada o haya un error
                ;
            END_IF
			
        E_GEMMA.F3SecuenciaFinalizacion: (* Secuencia de finalizacion *)
            IF Finalizada THEN
                gm.ModeActual := E_GEMMA.A1ParadaInicial;
            ELSE
                // continuar con la secuencia de finalización hasta que esté finalizada o haya un error
                ;
            END_IF
			
        E_GEMMA.F4VerificacionSinOrden: (* Verificacion sin orden *)
            IF Fallo THEN
                gm.ModePrev := E_GEMMA.F4VerificacionSinOrden; // DUDAS E_GEMMA.A2ParaFinCiclo; //!!! Creo que está mal, no debería ser F4?
                gm.ModeActual := E_GEMMA.D2TratamientoFallos;
            ELSIF NOT fbPanel.cn.Manual THEN
				gm.ModeActual := E_GEMMA.A6Inicializando; // después del modo manual, volver a inicializar
            ELSE
                // Seguir en modo manual hasta que halla un fallo o se vuelva al modo automático
                ;
            END_IF
			
        E_GEMMA.F5VerificacionOrdenada: (* Verificacion en orden *)
            ; // estado no tratado en la FMS205
			
        E_GEMMA.F6Probando: (* Prueba *)
            ; // estado no tratado en la FMS205

			
			
        (* ------------------------------------------------------------ Procedimientos de defecto *)
        E_GEMMA.D1ParadaEmergencia: (* Parada de emergencia *)
            IF NOT fbPanel.cn.Emergencia THEN
                gm.ModeActual := E_GEMMA.A6Inicializando; // Al quitar la parada de emergencia hay que reinicializar la estación
            ELSE
                // Esperar a que se quite la parada de emergencia
                ;
            END_IF
			
        E_GEMMA.D2TratamientoFallos: (* Diagnostico/tratamiento de los fallos *)
            IF NOT Fallo THEN
                gm.ModeActual := E_GEMMA.A5PreparandoTrasFallo;
            ELSE
                // Esperar a que se resuelva el fallo
                ;
            END_IF

        E_GEMMA.D3ProducirConFallos: (* Produccion a pesar de los fallos *)
            ; // estado no tratado en la FMS205

    END_CASE
END_IF

(* PARAMETROS DE SALIDA *)
gm.FamiArret  := (gm.ModeActual >= E_GEMMA.A1ParadaInicial) AND 
				 (gm.ModeActual <= E_GEMMA.A7SituandoEstado);
gm.FamiFonct  := (gm.ModeActual >= E_GEMMA.F1ProduccionNormal) AND 
				 (gm.ModeActual <= E_GEMMA.F6Probando);
gm.FamiDefail := (gm.ModeActual >= E_GEMMA.D1ParadaEmergencia) AND 
				 (gm.ModeActual <= E_GEMMA.D3ProducirConFallos);

]]></ST>
      </Implementation>
    </Method>
    <Method Name="F1ProduccionNormal" Id="{7ca323ea-768d-4b20-9a60-81cfe805fdbf}">
      <Declaration><![CDATA[METHOD F1ProduccionNormal : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbFMS205_Producir_SFC(		
	mdAlimentador 			:= mdAlimentador,
	mdPickAndPlaceCarga 	:= mdPickAndPlaceCarga,
	mdMedidorTapa			:= mdMedidorTapa,
	mdCaptadorInductivo 	:= mdCaptadorInductivo,
	mdDetectorFotoelectrico := mdDetectorFotoelectrico,
	mdEvacuador			 	:= mdEvacuador,
	mdPickAndPlaceDescarga 	:= mdPickAndPlaceDescarga,
	mdPlatoDivisor			:= mdPlatoDivisor,
	IC:=IC, Execute:=Execute, Ack:=Ack,
	Ready=>Ready, Done=>Done, Failure=>Failure);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="F5VerificacionOrdenada" Id="{cc903692-dfc3-4295-9550-eca76703506f}">
      <Declaration><![CDATA[METHOD F5VerificacionOrdenada : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[mdAlimentador.Execute           := dr.bot_Ejecutar AND dr.fun_Alimentar;
mdPickAndPlaceCarga.Execute     := dr.bot_Ejecutar AND dr.fun_Cargar;
mdMedidorTapa.Execute           := dr.bot_Ejecutar AND dr.fun_Altura;
mdDetectorFotoelectrico.Execute := dr.bot_Ejecutar AND dr.fun_Color;
mdCaptadorInductivo.Execute     := dr.bot_Ejecutar AND dr.fun_Material;
mdEvacuador.Execute             := dr.bot_Ejecutar AND dr.fun_Rechazar;
mdPickAndPlaceDescarga.Execute  := dr.bot_Ejecutar AND dr.fun_Descargar;
mdPlatoDivisor.Execute          := dr.bot_Ejecutar AND dr.fun_Girar;

mdAlimentador.Ack               := dr.bot_Continuar AND dr.fun_Alimentar;
mdPickAndPlaceCarga.Ack         := dr.bot_Continuar AND dr.fun_Cargar;
mdMedidorTapa.Ack               := dr.bot_Continuar AND dr.fun_Altura;
mdDetectorFotoelectrico.Ack     := dr.bot_Continuar AND dr.fun_Color;
mdCaptadorInductivo.Ack         := dr.bot_Continuar AND dr.fun_Material;
mdEvacuador.Ack                 := dr.bot_Continuar AND dr.fun_Rechazar;
mdPickAndPlaceDescarga.Ack      := dr.bot_Continuar AND dr.fun_Descargar;
mdPlatoDivisor.Ack              := dr.bot_Continuar AND dr.fun_Girar;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="InitialConditions" Id="{6c17034c-aab7-41fb-b0b6-e85a6db67498}">
      <Declaration><![CDATA[METHOD InitialConditions : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* La estación está en condiciones iniciales si cada módulo lo está *)
InitialConditions :=
	(
		mdAlimentador.InitialConditions() AND
		mdPickAndPlaceCarga.InitialConditions() AND
		mdMedidorTapa.InitialConditions() AND 
		mdCaptadorInductivo.InitialConditions() AND
		mdDetectorFotoelectrico.InitialConditions() AND
		mdEvacuador.InitialConditions() AND
		mdPickAndPlaceDescarga.InitialConditions() AND
		mdPlatoDivisor.InitialConditions() // TODO AND CINTA.INITIAL...
	); 
	// OR (fbDirector.Modo=E_GEMMA.F6Probando); // POST15 PARA FORZAR CONDICIONES INICIALES SIN HARDWARE !!! eliminar
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ProcessCycle" Id="{02e4c75f-69e3-444f-8a2e-ecad65532e26}">
      <Declaration><![CDATA[METHOD ProcessCycle : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[mdAlimentador.ModuleProcessCycle();
mdPickAndPlaceCarga.ModuleProcessCycle();
mdMedidorTapa.ModuleProcessCycle();
mdCaptadorInductivo.ModuleProcessCycle();
mdDetectorFotoelectrico.ModuleProcessCycle();
mdEvacuador.ModuleProcessCycle();
mdPickAndPlaceDescarga.ModuleProcessCycle();

tm.UpdateSpeed(NewSpeed:=100);// fbPanel.cn.NewSpeed); 

mdPlatoDivisor.tm REF=tm;
//mdPlatoDivisor.tm :=tm;
mdPlatoDivisor.ModuleProcessCycle();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="TestControl" Id="{640ad161-fd28-445e-8970-51dcaa5062c7}">
      <Declaration><![CDATA[METHOD TestControl : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// en el modo pruebas el control de la fms205 lo hacemos desde la visualización de pruebas

// utilidad para negar sensores cuando no hay máquina fisica conectada
td.FlancoNegar(CLK := td.Negar);
IF td.FlancoNegar.Q THEN
	mdPickAndPlaceCarga.NegarSensores();
	mdEvacuador.NegarSensores();
	mdPickAndPlaceDescarga.NegarSensores();
	mdPlatoDivisor.NegarSensores();
END_IF




//mdAlimentador.ModuleProcessCycle();	
//mdPickAndPlaceCarga.ModuleProcessCycle();	
//mdMedidorTapa.ModuleProcessCycle();	
//mdDetectorFotoelectrico.ModuleProcessCycle();	
//mdCaptadorInductivo.ModuleProcessCycle();	
//mdEvacuador.ModuleProcessCycle();	
//mdPickAndPlaceDescarga.ModuleProcessCycle();	
//mdPlatoDivisor.ModuleProcessCycle();	



	;
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>