<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_FMS205" Id="{a261f573-1402-443e-9bab-e88e0bf02070}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_FMS205
VAR_INPUT
	MaximoTiempoRespuesta: TIME := T#5S;
	ManiobrasDeseadas: UINT :=1; // POST15 AÑADIDO VALOR POR DEFECTO
END_VAR

VAR_OUTPUT
	ManiobrasRealizadas: UINT := 0;
	ManiobrasPendientes: UINT;
	
	IC: 		BOOL := FALSE; 	// todos los módulos están en condiciones iniciales
    Preparada : BOOL := TRUE;	// la estación está preparada después de encender
	FinCiclo: 	BOOL := FALSE;	// una pieza se ha completado
	FinTarea: 	BOOL := FALSE;	// el lote se ha completado
	Fallo: 		BOOL := FALSE;	// al menos un módulo ha fallado
    Finalizada: BOOL := TRUE;	// la estación está lista para apagarse    	
END_VAR

VAR
	// controladores de la máquina, la función de producción y la guía GEMMA 
	fbPanel					: FB_Panel;
	fbDirector				: FB_Director;
	ctInp 					: S_ControllerInput;
	
	// módulos de la FMS205
	mdAlimentador			: FB_Alimentador			(ID:=0, MRT:=MaximoTiempoRespuesta, Name:='Alimentador');
	mdPickAndPlaceCarga 	: FB_PickAndPlace			(ID:=1, MRT:=MaximoTiempoRespuesta, Name:='Carga');
	mdMedidorTapa			: FB_MedidorTapa			(ID:=3, MRT:=MaximoTiempoRespuesta, Name:='Medidor');
	mdCaptadorInductivo 	: FB_CaptadorInductivo		(ID:=4, MRT:=MaximoTiempoRespuesta, Name:='Inductivo');
	mdDetectorFotoelectrico : FB_DetectorFotoelectrico	(ID:=5, MRT:=MaximoTiempoRespuesta, Name:='Fotoeléctrico');
	mdEvacuador			 	: FB_Evacuador				(ID:=7, MRT:=MaximoTiempoRespuesta, Name:='Evacuador');
	mdPickAndPlaceDescarga 	: FB_PickAndPlace			(ID:=8, MRT:=MaximoTiempoRespuesta, Name:='Descarga');
	mdPlatoDivisor			: FB_PlatoDivisor			(ID:=9, MRT:=MaximoTiempoRespuesta, Name:='Plato');
	
	//fbFMS205_SFC			: FB_FMS205_SFC;
	fbFMS205_Producir_SFC	: FB_FMS205_SFC;

	

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbPanel();


IC:=				(* La estación está en condiciones iniciales si cada módulo lo está *)
	(mdAlimentador.InitialConditions() AND
	mdPickAndPlaceCarga.InitialConditions() AND
	mdMedidorTapa.InitialConditions() AND 
	mdCaptadorInductivo.InitialConditions() AND
	mdDetectorFotoelectrico.InitialConditions() AND
	mdEvacuador.InitialConditions() AND
	mdPickAndPlaceDescarga.InitialConditions()) 
	OR (fbDirector.Modo=E_GEMMA.F6Probando); // POST15 PARA FORZAR CONDICIONES INICIALES SIN HARDWARE 

	
Preparada := TRUE; // PENDIENTE SI LA ESTACIÓN NECESITA UNA SECUENCIA DE PREPARACIÓN 


FinCiclo := 		(* Todos los módulos han terminado su parte del ciclo *)
	mdAlimentador.ctOut.Done AND
	mdPickAndPlaceCarga.ctOut.Done AND
	mdMedidorTapa.ctOut.Done AND
	mdCaptadorInductivo.ctOut.Done AND
	mdDetectorFotoelectrico.ctOut.Done AND
	mdEvacuador.ctOut.Done AND
	mdPickAndPlaceDescarga.ctOut.Done AND
	mdPlatoDivisor.ctOut.Done;

IF FinCiclo THEN	
	// Todos los módulos han terminado su secuencia de producir
	// TODO SÓLO SE PUEDE CONTAR UNA TAPA HECHA SI NO SE HA RECHAZADO Y SI SE HA METIDO EN EL CARRO
	ManiobrasRealizadas := ManiobrasRealizadas + 1;
	// POAST15  ManiobrasPendientes := ManiobrasDeseadas - ManiobrasRealizadas;	
	// Añadir aquí LA LÓGICA DEL FINAL DE CICLO
	// p. ej. actualización del plato con los resultados de sensores  	
END_IF
ManiobrasPendientes := ManiobrasDeseadas - ManiobrasRealizadas; // POST15 hay que calcular siempre las maniobras pendientes

FinTarea := ManiobrasPendientes = 0; 	// Se finaliza la tarea si no quedan maniobras pendientes

Fallo:=									// La estaciónn está en fallo si al menos un módulo ha fallado
	mdAlimentador.ctOut.Fail OR
	mdPickAndPlaceCarga.ctOut.Fail OR
	mdMedidorTapa.ctOut.Fail OR 
	mdCaptadorInductivo.ctOut.Fail OR
	mdDetectorFotoelectrico.ctOut.Fail OR
	mdEvacuador.ctOut.Fail OR
	mdPickAndPlaceDescarga.ctOut.Fail; 

	
Finalizada := TRUE;	 // PENDIENTE SI LA ESTACIÓN NECESITA UNA SECUENCIA DE PREPARACIÓN 

fbDirector(
	fbPanel 	:= fbPanel,
	IC 			:= IC, 
	Preparada 	:= Preparada,
	FinCiclo	:= FinCiclo,
	FinTarea	:= FinTarea,
	Fallo		:= Fallo,
	Finalizada	:= Finalizada);
 

// IF fbDirector.Modo = E_Gemma.A6Inicializando THEN


// Informar la estructura ctInp que se copiará a todos y cada uno de los controladores
ctInp.ModeAct	:= fbDirector.Modo;
ctInp.ModePre	:= fbDirector.Previo;

ctInp.Execute :=  (* El coordinador indica que hay empezar *)
	(fbDirector.Modo = E_GEMMA.F6Probando AND fbPanel.ProbarExecute) OR
	(fbDirector.Modo <> E_GEMMA.F6Probando AND
		(
			(fbDirector.Modo = E_GEMMA.A2ParaFinCiclo) OR 
	 		(fbDirector.Modo = E_GEMMA.A3ParadaEstado) OR 
	 	 	(fbDirector.Modo = E_GEMMA.F1ProduccionNormal) OR 
	 	 	(fbDirector.Modo = E_GEMMA.F2SecuenciaPreparacion) OR 
	 	 	(fbDirector.Modo = E_GEMMA.F3SecuenciaFinalizacion) OR 
	 	 	(fbDirector.Modo = E_GEMMA.F5VerificacionOrdenada) OR 
	 	 	(fbDirector.Modo = E_GEMMA.F6Probando) OR 
	 	 	(fbDirector.Modo = E_GEMMA.D3ProducirConFallos)
		) 
	);
		

ctInp.Ack := // Notificar a los módulos que ya pueden volver al inicio
	(fbDirector.Modo = E_GEMMA.F6Probando AND fbPanel.ProbarAck) OR 
	(fbDirector.Modo <> E_GEMMA.F6Probando AND FinCiclo);
// TODO SI HAY FIN DE CICLO HAY QUE HACER UN MONTÓN DE COSAS, POR EJEMPLO, ACTUALIZAR EL PLATO CON EL SENSOR FOTOELÉCTRICO

ctInp.Manual := (* Establece modo de funcionamiento manual *) 
	(fbDirector.Modo = E_GEMMA.F4VerificacionSinOrden);
	
ctInp.Pause := (* Pausa la ejecucion de la funcionalidad  *)
	(fbDirector.Modo = E_GEMMA.A3ParadaEstado) OR 
	(fbDirector.Modo = E_GEMMA.A4ParadaObtenida) OR 
	(fbDirector.Modo = E_GEMMA.A5PreparandoTrasFallo) OR 
	(fbDirector.Modo = E_GEMMA.D1ParadaEmergencia) OR 
	(fbDirector.Modo = E_GEMMA.D2TratamientoFallos);

ctInp.Reset := (* Restablece la condicion de fallo *)
    (fbDirector.Modo = E_GEMMA.A5PreparandoTrasFallo);

ctInp.Restart := (* Reinicia el estado del controlador *)
	(fbDirector.Modo = E_GEMMA.A6Inicializando);

ctInp.Restore := (* Restaura las condiciones iniciales (referencia) *)
    (fbDirector.Modo=E_GEMMA.A6Inicializando); 

ctInp.Resume := (* Continua la ejecucion de la funcionalidad en curso *)
	(FALSE);
	
ctInp.Safe := (* Condicion de seguridad para iniciar una funcionalidad *)
	(TRUE);

	
// copiar la estructura ctInp en todos los módulos para distribuir la misma información de entrada
mdAlimentador.ctInp 			:= ctInp;
mdPickAndPlaceCarga.ctInp 		:= ctInp;
mdMedidorTapa.ctInp 			:= ctInp;
mdCaptadorInductivo.ctInp 		:= ctInp;
mdDetectorFotoelectrico.ctInp 	:= ctInp;
mdEvacuador.ctInp 				:= ctInp;
mdPickAndPlaceDescarga.ctInp 	:= ctInp;
mdPlatoDivisor.ctInp 			:= ctInp;

mdEvacuador.Evacuar := TRUE; // TODO PENDIENTE DECISIÓN DE EVACUAR O NO EN FUNCIÓN DEL TIPO DE TAPA
mdPickAndPlaceCarga.Mover := TRUE;
mdPickAndPlaceDescarga.Mover := TRUE;

// TODO CARGA Y DESCARGA TENGAN UNA OPCION DE NO HACER NADA

IF fbDirector.Modo = E_GEMMA.F6Probando THEN
	// en el modo pruebas el control de la fms205 lo hacemos desde la visualización de pruebas
	//ctInp.Execute 	:= fbPanel.ProbarExecute;
	//ctInp.Ack 		:= fbPanel.ProbarAck; 
	IF fbPanel.ProbarAlimentador THEN
		mdAlimentador.ModuleProcessCycle();	
	END_IF
	IF fbPanel.ProbarCarga THEN
		IF fbPanel.FlancoNegarSensores THEN
			mdPickAndPlaceCarga.NegarSensores();
		END_IF
		mdPickAndPlaceCarga.ModuleProcessCycle();	
	END_IF
	IF fbPanel.ProbarMedidor THEN
		mdMedidorTapa.ModuleProcessCycle();	
	END_IF
		IF fbPanel.ProbarFotoelectrico THEN
		mdDetectorFotoelectrico.ModuleProcessCycle();	
	END_IF
	IF fbPanel.ProbarInductivo THEN
		mdCaptadorInductivo.ModuleProcessCycle();	
	END_IF
	IF fbPanel.ProbarEvacuador THEN
		mdEvacuador.ModuleProcessCycle();	
	END_IF
	IF fbPanel.ProbarDescarga THEN
		IF fbPanel.FlancoNegarSensores THEN
			mdPickAndPlaceDescarga.NegarSensores();
		END_IF		
		mdPickAndPlaceDescarga.ModuleProcessCycle();	
	END_IF
	IF fbPanel.ProbarPlato THEN
		IF fbPanel.FlancoNegarSensores THEN
			mdPlatoDivisor.NegarSensores();
		END_IF
		mdPlatoDivisor.ModuleProcessCycle();	
	END_IF


	;
ELSE
	fbFMS205_Producir_SFC(
		ctInp					:= ctInp, // POST15
		mdAlimentador 			:= mdAlimentador,
		mdPickAndPlaceCarga 	:= mdPickAndPlaceCarga,
		mdMedidorTapa			:= mdMedidorTapa,
		mdCaptadorInductivo 	:= mdCaptadorInductivo,
		mdDetectorFotoelectrico := mdDetectorFotoelectrico,
		mdEvacuador			 	:= mdEvacuador,
		mdPickAndPlaceDescarga 	:= mdPickAndPlaceDescarga,
		mdPlatoDivisor			:= mdPlatoDivisor);
	mdAlimentador.ModuleProcessCycle();
	mdPickAndPlaceCarga.ModuleProcessCycle();
	mdMedidorTapa.ModuleProcessCycle();
	mdCaptadorInductivo.ModuleProcessCycle();
	mdDetectorFotoelectrico.ModuleProcessCycle();
	mdEvacuador.ModuleProcessCycle();
	mdPickAndPlaceDescarga.ModuleProcessCycle();
	mdPlatoDivisor.ModuleProcessCycle();
END_IF

]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>