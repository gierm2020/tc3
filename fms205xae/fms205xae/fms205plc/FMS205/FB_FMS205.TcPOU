<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_FMS205" Id="{a261f573-1402-443e-9bab-e88e0bf02070}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_FMS205
VAR_INPUT
	ManiobrasDeseadas: UINT :=1; // POST15 AÑADIDO VALOR POR DEFECTO
END_VAR

VAR_OUTPUT
	gm					: S_GEMMA; 		// Información sobre la familia y modo GEMMA en que se encuentra la estación
	tm					: S_Timeouts; 	// Valores de temporizadores
	
	td					: S_TestData; 	// Consignas relacionadas con el modo de pruebas
	
	ManiobrasRealizadas: UINT := 0;
	ManiobrasPendientes: UINT;
	
	IC: 		BOOL := FALSE; 	// todos los módulos están en condiciones iniciales
    Preparada : BOOL := TRUE;	// la estación está preparada después de encender
	FinCiclo: 	BOOL := FALSE;	// una pieza se ha completado
	FinTarea: 	BOOL := FALSE;	// el lote se ha completado
	Fallo: 		BOOL := FALSE;	// al menos un módulo ha fallado
    Finalizada: BOOL := TRUE;	// la estación está lista para apagarse    	
END_VAR

VAR
	// controladores de la máquina, la función de producción y la guía GEMMA 
	fbPanel					: FB_Panel;
	// fbDirector				: FB_Director;
	ctInp 					: S_ControllerInput := (tm := tm);
	
	// módulos de la FMS205
	mdAlimentador			: FB_Alimentador			(ID:=0, MRT:=tm.MaximoTiempoRespuesta, Name:='Alimentador');
	mdPickAndPlaceCarga 	: FB_PickAndPlace			(ID:=1, MRT:=tm.MaximoTiempoRespuesta, Name:='Carga');
	mdMedidorTapa			: FB_MedidorTapa			(ID:=3, MRT:=tm.MaximoTiempoRespuesta, Name:='Medidor');
	mdCaptadorInductivo 	: FB_CaptadorInductivo		(ID:=4, MRT:=tm.MaximoTiempoRespuesta, Name:='Inductivo');
	mdDetectorFotoelectrico : FB_DetectorFotoelectrico	(ID:=5, MRT:=tm.MaximoTiempoRespuesta, Name:='Fotoeléctrico');
	mdEvacuador			 	: FB_Evacuador				(ID:=7, MRT:=tm.MaximoTiempoRespuesta, Name:='Evacuador');
	mdPickAndPlaceDescarga 	: FB_PickAndPlace			(ID:=8, MRT:=tm.MaximoTiempoRespuesta, Name:='Descarga');
	mdPlatoDivisor			: FB_PlatoDivisor			(ID:=9, MRT:=tm.MaximoTiempoRespuesta, Name:='Plato');
	mdCinta					: FB_Cinta					(ID:=10,MRT:=tm.MaximoTiempoRespuesta, Name:='Cinta');
	//fbFMS205_SFC			: FB_FMS205_SFC;
	fbFMS205_Producir_SFC	: FB_FMS205_SFC;

	

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbPanel();


IC := InitialConditions(); // comprueba si todos los módulos cumplen las condiciones iniciales	
	
Preparada := TRUE; // PENDIENTE SI LA ESTACIÓN NECESITA UNA SECUENCIA DE PREPARACIÓN 


FinCiclo := 		(* Todos los módulos han terminado su parte del ciclo *)
	mdAlimentador.ctOut.Done AND
	mdPickAndPlaceCarga.ctOut.Done AND
	mdMedidorTapa.ctOut.Done AND
	mdCaptadorInductivo.ctOut.Done AND
	mdDetectorFotoelectrico.ctOut.Done AND
	mdEvacuador.ctOut.Done AND
	mdPickAndPlaceDescarga.ctOut.Done AND
	mdPlatoDivisor.ctOut.Done;

IF FinCiclo THEN	
	// Todos los módulos han terminado su secuencia de producir
	// TODO SÓLO SE PUEDE CONTAR UNA TAPA HECHA SI NO SE HA RECHAZADO Y SI SE HA METIDO EN EL CARRO
	ManiobrasRealizadas := ManiobrasRealizadas + 1;
	// POAST15  ManiobrasPendientes := ManiobrasDeseadas - ManiobrasRealizadas;	
	// Añadir aquí LA LÓGICA DEL FINAL DE CICLO
	// p. ej. actualización del plato con los resultados de sensores  	
END_IF
ManiobrasPendientes := ManiobrasDeseadas - ManiobrasRealizadas; // POST15 hay que calcular siempre las maniobras pendientes

FinTarea := ManiobrasPendientes = 0; 	// Se finaliza la tarea si no quedan maniobras pendientes

Fallo:=									// La estaciónn está en fallo si al menos un módulo ha fallado
	mdAlimentador.ctOut.Fail OR
	mdPickAndPlaceCarga.ctOut.Fail OR
	mdMedidorTapa.ctOut.Fail OR 
	mdCaptadorInductivo.ctOut.Fail OR
	mdDetectorFotoelectrico.ctOut.Fail OR
	mdEvacuador.ctOut.Fail OR
	mdPickAndPlaceDescarga.ctOut.Fail; 

	
Finalizada := TRUE;	 // PENDIENTE SI LA ESTACIÓN NECESITA UNA SECUENCIA DE PREPARACIÓN 

Director();
(*
fbDirector(
	fbPanel 	:= fbPanel,
	IC 			:= IC, 
	Preparada 	:= Preparada,
	FinCiclo	:= FinCiclo,
	FinTarea	:= FinTarea,
	Fallo		:= Fallo,
	Finalizada	:= Finalizada);
*)

// IF fbDirector.Modo = E_Gemma.A6Inicializando THEN


// Informar la estructura ctInp que se copiará a todos y cada uno de los controladores
ctInp.ModeAct	:= gm.ModeActual;
ctInp.ModePre	:= gm.ModePrev;

ctInp.Execute :=  (* El coordinador indica que hay empezar *)
	(gm.ModeActual = E_GEMMA.F6Probando AND td.Execute) OR
	(gm.ModeActual <> E_GEMMA.F6Probando AND
		(
			(gm.ModeActual = E_GEMMA.A2ParaFinCiclo) OR 
	 		(gm.ModeActual = E_GEMMA.A3ParadaEstado) OR 
	 	 	(gm.ModeActual = E_GEMMA.F1ProduccionNormal) OR 
	 	 	(gm.ModeActual = E_GEMMA.F2SecuenciaPreparacion) OR 
	 	 	(gm.ModeActual = E_GEMMA.F3SecuenciaFinalizacion) OR 
	 	 	(gm.ModeActual = E_GEMMA.F5VerificacionOrdenada) OR 
	 	 	(gm.ModeActual = E_GEMMA.F6Probando) OR 
	 	 	(gm.ModeActual = E_GEMMA.D3ProducirConFallos)
		) 
	);
		

ctInp.Ack := // Notificar a los módulos que ya pueden volver al inicio
	(gm.ModeActual = E_GEMMA.F6Probando AND td.Ack) OR 
	(gm.ModeActual <> E_GEMMA.F6Probando AND FinCiclo);
// TODO SI HAY FIN DE CICLO HAY QUE HACER UN MONTÓN DE COSAS, POR EJEMPLO, ACTUALIZAR EL PLATO CON EL SENSOR FOTOELÉCTRICO

ctInp.Manual := (* Establece modo de funcionamiento manual *) 
	(gm.ModeActual = E_GEMMA.F4VerificacionSinOrden);
	
ctInp.Pause := (* Pausa la ejecucion de la funcionalidad  *)
	(gm.ModeActual = E_GEMMA.A3ParadaEstado) OR 
	(gm.ModeActual = E_GEMMA.A4ParadaObtenida) OR 
	(gm.ModeActual = E_GEMMA.A5PreparandoTrasFallo) OR 
	(gm.ModeActual = E_GEMMA.D1ParadaEmergencia) OR 
	(gm.ModeActual = E_GEMMA.D2TratamientoFallos);

ctInp.Reset := (* Restablece la condicion de fallo *)
    (gm.ModeActual = E_GEMMA.A5PreparandoTrasFallo);

ctInp.Restart := (* Reinicia el estado del controlador *)
	(gm.ModeActual = E_GEMMA.A6Inicializando);

ctInp.Restore := (* Restaura las condiciones iniciales (referencia) *)
    (gm.ModeActual=E_GEMMA.A6Inicializando); 

ctInp.Resume := (* Continua la ejecucion de la funcionalidad en curso *)
	(FALSE);
	
ctInp.Safe := (* Condicion de seguridad para iniciar una funcionalidad *)
	(TRUE);

	
// copiar la estructura ctInp en todos los módulos para distribuir la misma información de entrada
mdAlimentador.ctInp 			:= ctInp;
mdPickAndPlaceCarga.ctInp 		:= ctInp;
mdMedidorTapa.ctInp 			:= ctInp;
mdCaptadorInductivo.ctInp 		:= ctInp;
mdDetectorFotoelectrico.ctInp 	:= ctInp;
mdEvacuador.ctInp 				:= ctInp;
mdPickAndPlaceDescarga.ctInp 	:= ctInp;
mdPlatoDivisor.ctInp 			:= ctInp;

mdEvacuador.Evacuar := TRUE; // TODO PENDIENTE DECISIÓN DE EVACUAR O NO EN FUNCIÓN DEL TIPO DE TAPA
mdPickAndPlaceCarga.Mover := TRUE;
mdPickAndPlaceDescarga.Mover := TRUE;

// TODO CARGA Y DESCARGA TENGAN UNA OPCION DE NO HACER NADA

IF gm.ModeActual = E_GEMMA.F6Probando THEN
	F6TestingMode();
ELSE
	fbFMS205_Producir_SFC(
		ctInp					:= ctInp, // POST15
		mdAlimentador 			:= mdAlimentador,
		mdPickAndPlaceCarga 	:= mdPickAndPlaceCarga,
		mdMedidorTapa			:= mdMedidorTapa,
		mdCaptadorInductivo 	:= mdCaptadorInductivo,
		mdDetectorFotoelectrico := mdDetectorFotoelectrico,
		mdEvacuador			 	:= mdEvacuador,
		mdPickAndPlaceDescarga 	:= mdPickAndPlaceDescarga,
		mdPlatoDivisor			:= mdPlatoDivisor);
	mdAlimentador.ModuleProcessCycle();
	mdPickAndPlaceCarga.ModuleProcessCycle();
	mdMedidorTapa.ModuleProcessCycle();
	mdCaptadorInductivo.ModuleProcessCycle();
	mdDetectorFotoelectrico.ModuleProcessCycle();
	mdEvacuador.ModuleProcessCycle();
	mdPickAndPlaceDescarga.ModuleProcessCycle();
	mdPlatoDivisor.ModuleProcessCycle();
END_IF

]]></ST>
    </Implementation>
    <Method Name="Director" Id="{607386c6-63f2-4de2-a057-037fe1b8c79f}">
      <Declaration><![CDATA[METHOD Director : BOOL
// Actualiza el estado de la estación siguiendo el estándar definido la guía GEMMA]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* FUNCION DE ESTADO *)


IF fbPanel.Emergencia THEN
    gm.ModeActual := E_GEMMA.D1ParadaEmergencia;
	
	
ELSIF fbPanel.Reinicia THEN
    gm.ModeActual := E_GEMMA.A6Inicializando;

ELSIF fbPanel.Probando AND gm.ModeActual <> E_GEMMA.F6Probando THEN
	gm.ModePrev := gm.ModeActual; 			// guardamos el modo en que estaba la máquiina antes de entrar a modo pruebas
	gm.ModeActual := E_GEMMA.F6Probando; 	// y pasamos al modo pruebas 

ELSIF gm.ModeActual = E_GEMMA.F6Probando AND NOT fbPanel.Probando THEN
	gm.ModeActual := gm.ModePrev; 			// restauramos el modo en que estaba la máquina antes de pasar a modo pruebas
    // Previo := E_GEMMA.F6Probando;		// y el modo previo queda a F6 DUDAS


ELSE
    CASE gm.ModeActual OF
		
	
        (* ------------------------------------------------------------ Procedimientos de parada *)
		
        E_GEMMA.A1ParadaInicial: (* Parada en el estado inicial *)
            IF NOT InitialConditions() THEN // IF NOT Restaurada THEN
                gm.ModeActual := E_GEMMA.A6Inicializando;
            ELSIF fbPanel.Manual THEN
                gm.ModeActual := E_GEMMA.F4VerificacionSinOrden;
            ELSIF fbPanel.Marcha AND IC THEN  // ELSIF Marcha THEN
                gm.ModeActual := E_GEMMA.F2SecuenciaPreparacion;
			ELSE
				; // Esperar a que se pulse el bortón de marcha
            END_IF
			
        E_GEMMA.A2ParaFinCiclo: (* Parada solicitada a final de ciclo *)
            IF Fallo THEN
                gm.ModePrev := E_GEMMA.A2ParaFinCiclo;
                gm.ModeActual := E_GEMMA.D2TratamientoFallos;
            ELSIF FinCiclo THEN
                gm.ModeActual := E_GEMMA.A1ParadaInicial;
            ELSE
                // Seguir produciendo hasta final de ciclo
                ;
            END_IF
			
        E_GEMMA.A3ParadaEstado: (* Parada solicitada en un estado determinado *)
            ; // estado no tratado en la FMS205 DUDAS
			
        E_GEMMA.A4ParadaObtenida: (* Parada obtenida *)
            ; // estado no tratado en la FMS205 DUDAS
        
		E_GEMMA.A5PreparandoTrasFallo: (* Preparando de reanudacion tras el fallo *)
            IF fbPanel.Marcha THEN // Continua
                gm.ModeActual := gm.ModePrev;
            ELSIF fbPanel.Para THEN // Cancela
                gm.ModeActual := E_GEMMA.A6Inicializando;
				gm.ModePrev := gm.ModeActual; // DUDAS
            END_IF
			
        E_GEMMA.A6Inicializando: (* Situando la PO en el estado inicial *)
            IF IC THEN // Restaurada
                gm.ModeActual := E_GEMMA.A1ParadaInicial;
            ELSIF fbPanel.Manual THEN
                gm.ModeActual := E_GEMMA.F4VerificacionSinOrden;
            END_IF
			
        E_GEMMA.A7SituandoEstado: (* Situando la PO en un estado determinado *)
            ; // estado no tratado en la FMS205

			
			
        (* ------------------------------------------------------------ Procedimientos de funcionamiento *)
        
		E_GEMMA.F1ProduccionNormal: (* Produccion normal *)
            IF Fallo THEN
                gm.ModePrev := E_GEMMA.F1ProduccionNormal; // DUDAS E_GEMMA.A2ParaFinCiclo; //!!! Creo que está mal, no debería ser F1?
                gm.ModeActual := E_GEMMA.D2TratamientoFallos;
            ELSIF FinTarea THEN
                gm.ModeActual := E_GEMMA.F3SecuenciaFinalizacion;
            ELSIF fbPanel.Para THEN
                gm.ModeActual := E_GEMMA.A2ParaFinCiclo;
            END_IF
			
        E_GEMMA.F2SecuenciaPreparacion: (* Secuencia de preparacion *)
            IF Preparada THEN
                gm.ModeActual := E_GEMMA.F1ProduccionNormal;
            ELSE
                // continuar con la secuencia de preparación hasta que esté preparada o haya un error
                ;
            END_IF
			
        E_GEMMA.F3SecuenciaFinalizacion: (* Secuencia de finalizacion *)
            IF Finalizada THEN
                gm.ModeActual := E_GEMMA.A1ParadaInicial;
            ELSE
                // continuar con la secuencia de finalización hasta que esté finalizada o haya un error
                ;
            END_IF
			
        E_GEMMA.F4VerificacionSinOrden: (* Verificacion sin orden *)
            IF Fallo THEN
                gm.ModePrev := E_GEMMA.F4VerificacionSinOrden; // DUDAS E_GEMMA.A2ParaFinCiclo; //!!! Creo que está mal, no debería ser F4?
                gm.ModeActual := E_GEMMA.D2TratamientoFallos;
            ELSIF NOT fbPanel.Manual THEN
				gm.ModeActual := E_GEMMA.A6Inicializando; // después del modo manual, volver a inicializar
            ELSE
                // Seguir en modo manual hasta que halla un fallo o se vuelva al modo automático
                ;
            END_IF
			
        E_GEMMA.F5VerificacionOrdenada: (* Verificacion en orden *)
            ; // estado no tratado en la FMS205
			
        E_GEMMA.F6Probando: (* Prueba *)
            ; // estado no tratado en la FMS205

			
			
        (* ------------------------------------------------------------ Procedimientos de defecto *)
        E_GEMMA.D1ParadaEmergencia: (* Parada de emergencia *)
            IF NOT fbPanel.Emergencia THEN
                gm.ModeActual := E_GEMMA.A6Inicializando; // Al quitar la parada de emergencia hay que reinicializar la estación
            ELSE
                // Esperar a que se quite la parada de emergencia
                ;
            END_IF
			
        E_GEMMA.D2TratamientoFallos: (* Diagnostico/tratamiento de los fallos *)
            IF NOT Fallo THEN
                gm.ModeActual := E_GEMMA.A5PreparandoTrasFallo;
            ELSE
                // Esperar a que se resuelva el fallo
                ;
            END_IF

        E_GEMMA.D3ProducirConFallos: (* Produccion a pesar de los fallos *)
            ; // estado no tratado en la FMS205

    END_CASE
END_IF

(* PARAMETROS DE SALIDA *)
gm.FamiArret  := (gm.ModeActual >= E_GEMMA.A1ParadaInicial) AND 
				 (gm.ModeActual <= E_GEMMA.A7SituandoEstado);
gm.FamiFonct  := (gm.ModeActual >= E_GEMMA.F1ProduccionNormal) AND 
				 (gm.ModeActual <= E_GEMMA.F6Probando);
gm.FamiDefail := (gm.ModeActual >= E_GEMMA.D1ParadaEmergencia) AND 
				 (gm.ModeActual <= E_GEMMA.D3ProducirConFallos);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="F6TestingMode" Id="{697643b6-2262-4b9f-9ecb-336a91083aa9}">
      <Declaration><![CDATA[METHOD F6TestingMode : BOOL

]]></Declaration>
      <Implementation>
        <ST><![CDATA[// en el modo pruebas el control de la fms205 lo hacemos desde la visualización de pruebas
	//ctInp.Execute 	:= fbPanel.ProbarExecute;
	//ctInp.Ack 		:= fbPanel.ProbarAck;

// Cambiar el estado de los sensores cuando hay un flanco positivo del control de cambio de estado de sensores
td.FlancoNegar(CLK := td.Negar);
IF td.FlancoNegar.Q THEN
	mdAlimentador.NegarSensores();
	mdPickAndPlaceCarga.NegarSensores();
	mdMedidorTapa.NegarSensores();
	mdDetectorFotoelectrico.NegarSensores();
	mdCaptadorInductivo.NegarSensores();
	mdEvacuador.NegarSensores();
	mdPickAndPlaceDescarga.NegarSensores();
	mdCinta.NegarSensores();
END_IF


// Ejecutar los módulos que se pidan
IF td.Alime THEN
	mdAlimentador.ModuleProcessCycle();	
END_IF
IF td.Carga THEN
	IF fbPanel.FlancoNegarSensores THEN
		mdPickAndPlaceCarga.NegarSensores();
	END_IF
	mdPickAndPlaceCarga.ModuleProcessCycle();	
END_IF
IF td.Medid THEN
	mdMedidorTapa.ModuleProcessCycle();	
END_IF
	IF fbPanel.ProbarFotoelectrico THEN
	mdDetectorFotoelectrico.ModuleProcessCycle();	
END_IF
IF td.Induc THEN
	mdCaptadorInductivo.ModuleProcessCycle();	
END_IF
IF td.Evacu THEN
	mdEvacuador.ModuleProcessCycle();	
END_IF
IF td.Desca THEN
	IF fbPanel.FlancoNegarSensores THEN
		mdPickAndPlaceDescarga.NegarSensores();
	END_IF		
	mdPickAndPlaceDescarga.ModuleProcessCycle();	
END_IF
IF td.Plato THEN
	IF fbPanel.FlancoNegarSensores THEN
		mdPlatoDivisor.NegarSensores();
	END_IF
	mdPlatoDivisor.ModuleProcessCycle();	
END_IF


	;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="InitialConditions" Id="{ced68a35-410b-4233-b292-485a89563ec3}">
      <Declaration><![CDATA[METHOD InitialConditions : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* La estación está en condiciones iniciales si cada módulo lo está *)
InitialConditions :=			
	mdAlimentador.InitialConditions() AND
	mdPickAndPlaceCarga.InitialConditions() AND
	mdMedidorTapa.InitialConditions() AND 
	mdCaptadorInductivo.InitialConditions() AND
	mdDetectorFotoelectrico.InitialConditions() AND
	mdEvacuador.InitialConditions() AND
	mdPickAndPlaceDescarga.InitialConditions() AND
	mdCinta.InitialConditions();
 
	// OR (fbDirector.Modo=E_GEMMA.F6Probando); // POST15 PARA FORZAR CONDICIONES INICIALES SIN HARDWARE !!! eliminar
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>