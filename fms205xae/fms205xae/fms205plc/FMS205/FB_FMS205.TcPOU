<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.6">
  <POU Name="FB_FMS205" Id="{a261f573-1402-443e-9bab-e88e0bf02070}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_FMS205
(* Rama Laura  prueba de push*)

VAR_INPUT
	IC		: BOOL := FALSE; 	// todos los módulos están en condiciones iniciales
    Execute	: BOOL;
	Ack 	: BOOL;
END_VAR

VAR_OUTPUT
	Ready	: BOOL;
	Failure	: BOOL;
	Done	: BOOL;	
END_VAR	
(*
VAR 
	ProdRequerida	: UINT := 2;
	ProdRealizada	: UINT := 0;
	ProdPendiente	: UINT := 2;
	ProdRechazada	: UINT := 0;
	FinCiclo		: BOOL := FALSE;	// una pieza se ha completado
	FinTarea		: BOOL := FALSE;	// el lote se ha completado
END_VAR
*)
//VAR_INPUT
//	MaximoTiempoRespuesta: TIME := T#5S;
//	ManiobrasDeseadas: UINT :=1; // POST15 AÑADIDO VALOR POR DEFECTO
//END_VAR
(*
VAR_OUTPUT
	//ManiobrasRealizadas: UINT := 0;
	//ManiobrasPendientes: UINT;
	
	Preparada : BOOL := TRUE;	// la estación está preparada después de encender
	Fallo: 		BOOL := FALSE;	// al menos un módulo ha fallado
    Finalizada: BOOL := TRUE;	// la estación está lista para apagarse    	
END_VAR
*)
	//numGiros 	: DINT := 0;
	//angulo	 	: REAL := 0.0;
	//anguloanim 	: REAL := 0.0; // angulo para animación que gira lentamente
	//girado		: BOOL := FALSE;
	//sectores 	: ARRAY [0..7] OF FB_Sector;
	

VAR
	// controladores de la máquina, la función de producción y la guía GEMMA 
	dr						: FB_Director;
	tapas					: FB_Tapas;
	
	// módulos de la FMS205
	mdAlimentador			: FB_Alimentador			:= (dr:=dr, ID := 1, Name := 'Alimentador');
	mdPickAndPlaceCarga 	: FB_PickAndPlace			:= (dr:=dr, ID := 2, Name := 'Carga');
	mdMedidorTapa			: FB_MedidorTapa			:= (dr:=dr, ID := 3, Name := 'Medidor');
	mdCaptadorInductivo 	: FB_CaptadorInductivo		:= (dr:=dr, ID := 4, Name := 'Inductivo');
	mdDetectorFotoelectrico : FB_DetectorFotoelectrico	:= (dr:=dr, ID := 5, Name := 'Fotoeléctrico');
	mdEvacuador			 	: FB_Evacuador				:= (dr:=dr, ID := 6, Name := 'Evacuador');
	mdPickAndPlaceDescarga 	: FB_PickAndPlace			:= (dr:=dr, ID := 7, Name := 'Descarga');
	mdPlatoDivisor			: FB_PlatoDivisor			:= (dr:=dr, ID := 8, Name := 'Plato');
	mdCinta					: FB_Cinta					:= (dr:=dr, ID := 9, Name := 'Cinta');
	
	fbPanel					: FB_Panel := (dr := dr);	
	ctrlF1Producir			: FB_FMS205_F1Producir_SFC; 
	ctrlF2SeqPrep			: FB_FMS205_F2SeqPrep_SFC;		
	ctrlF3SeqFin			: FB_FMS205_F3SeqFin_SFC;		
	ctrlF6Prueba			: FB_FMS205_F6Prueba_SFC;
END_VAR

(*
VAR
	PosCarga 	: DINT;
	PosMedid	: DINT;
	PosFotoe	: DINT;
	PosInduc	: DINT;
	PosEvacu	: DINT;
	PosDesca	: DINT;

END_VAR
*)]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*
	fbPanel(gm:=gm);
	IC:=InitialConditions();
	Preparada := TRUE; // PENDIENTE SI LA ESTACIÓN NECESITA UNA SECUENCIA DE PREPARACIÓN 
	
	
	FinCiclo := 		(* Todos los módulos han terminado su parte del ciclo *)
		mdAlimentador.Done AND
		mdPickAndPlaceCarga.Done AND
		mdMedidorTapa.Done AND
		mdCaptadorInductivo.Done AND
		mdDetectorFotoelectrico.Done AND
		mdEvacuador.Done AND
		mdPickAndPlaceDescarga.Done AND
		mdPlatoDivisor.Done AND
		mdCinta.Done;
	
	IF FinCiclo THEN	
		// Todos los módulos han terminado su secuencia de producir
		// TODO SÓLO SE PUEDE CONTAR UNA TAPA HECHA SI NO SE HA RECHAZADO Y SI SE HA METIDO EN EL CARRO
		ManiobrasRealizadas := ManiobrasRealizadas + 1;
		// POAST15  ManiobrasPendientes := ManiobrasDeseadas - ManiobrasRealizadas;	
		// Añadir aquí LA LÓGICA DEL FINAL DE CICLO
		// p. ej. actualización del plato con los resultados de sensores  	
	END_IF
	ManiobrasPendientes := ManiobrasDeseadas - ManiobrasRealizadas; // POST15 hay que calcular siempre las maniobras pendientes
	
	FinTarea := ManiobrasPendientes = 0; 	// Se finaliza la tarea si no quedan maniobras pendientes
	
	Fallo:=									// La estaciónn está en fallo si al menos un módulo ha fallado
		mdAlimentador.Failure OR
		mdPickAndPlaceCarga.Failure OR
		mdMedidorTapa.Failure OR 
		mdCaptadorInductivo.Failure OR
		mdDetectorFotoelectrico.Failure OR
		mdEvacuador.Failure OR
		mdPickAndPlaceDescarga.Failure OR
		mdCinta.Failure; 
	
		
	Finalizada := TRUE;	 // PENDIENTE SI LA ESTACIÓN NECESITA UNA SECUENCIA DE PREPARACIÓN 
	Director();
	
	Execute :=  (* El coordinador indica que hay empezar *)
		(gm.ModeActual = E_GEMMA.F6Probando AND dr.bot_Ejecutar) OR // td.Execute) OR
		(gm.ModeActual <> E_GEMMA.F6Probando AND
			(
				(gm.ModeActual = E_GEMMA.A2ParaFinCiclo) OR 
				(gm.ModeActual = E_GEMMA.A3ParadaEstado) OR 
				(gm.ModeActual = E_GEMMA.F1ProduccionNormal) OR 
				(gm.ModeActual = E_GEMMA.F2SecuenciaPreparacion) OR 
				(gm.ModeActual = E_GEMMA.F3SecuenciaFinalizacion) OR 
				(gm.ModeActual = E_GEMMA.F5VerificacionOrdenada) OR 
				(gm.ModeActual = E_GEMMA.F6Probando) OR 
				(gm.ModeActual = E_GEMMA.D3ProducirConFallos)
			) 
		);
			
	
	Ack := // Notificar a los módulos que ya pueden volver al inicio
		(gm.ModeActual = E_GEMMA.F6Probando AND dr.bot_Continuar) OR 
		(gm.ModeActual <> E_GEMMA.F6Probando AND FinCiclo);
	// TODO SI HAY FIN DE CICLO HAY QUE HACER UN MONTÓN DE COSAS, POR EJEMPLO, ACTUALIZAR EL PLATO CON EL SENSOR FOTOELÉCTRICO
	
	
	mdEvacuador.Evacuar := TRUE; // TODO PENDIENTE DECISIÓN DE EVACUAR O NO EN FUNCIÓN DEL TIPO DE TAPA
	mdPickAndPlaceCarga.Mover := TRUE;
	mdPickAndPlaceDescarga.Mover := TRUE;
	

	// TODO CARGA Y DESCARGA TENGAN UNA OPCION DE NO HACER NADA
	
	IF dr.ModeActual = E_GEMMA.F5VerificacionOrdenada THEN //IF gm.ModeActual = E_GEMMA.F6Probando THEN
		; // TestControl();
	ELSE
		fbFMS205_Producir_SFC(		
			mdAlimentador 			:= mdAlimentador,
			mdPickAndPlaceCarga 	:= mdPickAndPlaceCarga,
			mdMedidorTapa			:= mdMedidorTapa,
			mdCaptadorInductivo 	:= mdCaptadorInductivo,
			mdDetectorFotoelectrico := mdDetectorFotoelectrico,
			mdEvacuador			 	:= mdEvacuador,
			mdPickAndPlaceDescarga 	:= mdPickAndPlaceDescarga,
			mdPlatoDivisor			:= mdPlatoDivisor,
			mdCinta					:= mdCinta,
			IC:=IC, Execute:=Execute, Ack:=Ack,
			Ready=>Ready, Done=>Done, Failure=>Failure);
	
	END_IF
END_IF
ProcessCycle();
	*)
	

]]></ST>
    </Implementation>
    <Method Name="FlowControl" Id="{7553d21c-2ad5-400d-89ea-a2f83e6494f7}">
      <Declaration><![CDATA[METHOD FlowControl : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE dr.gmModeActual OF
	E_GEMMA.A1ParadaInicial,
	E_GEMMA.A4ParadaObtenida:
		; // esperar la puesta en marcha o reanudar tras parada

	E_GEMMA.A3ParadaEstado: 
		dr.IsStopped := IsStopped(); // esperar a que todos los módulos se detengan
	
	E_GEMMA.A5PreparandoTrasFallo:
		; // pendiente implementar
 
	E_GEMMA.A6Inicializando:
		tapas.Inicializar();
		dr.IC						:= InitialConditions();
		dr.Failure 					:= FALSE;
		dr.EndCycle 				:= FALSE;
		dr.EndBatch					:= FALSE;
		dr.IsStopped				:= FALSE; // IsStopped(); TODO
		ctrlF1Producir.Execute		:= TRUE;
		ctrlF1Producir.Ack			:= FALSE;
		ctrlF2SeqPrep.Execute		:= TRUE; // TODO CONSIGNA F2
		ctrlF2SeqPrep.Ack 			:= FALSE;
		ctrlF3SeqFin.Execute		:= TRUE; // TODO CONSIGNA F3
		ctrlF3SeqFin.Ack			:= FALSE;
		ctrlF6Prueba.Execute		:= TRUE; // TODO CONSIGNA F6
		ctrlF6Prueba.Ack 			:= FALSE;
		

	E_GEMMA.F2SecuenciaPreparacion:
		ctrlF2SeqPrep(Medid:=mdMedidorTapa, Fotoe:=mdDetectorFotoelectrico, 
			Induc:=mdCaptadorInductivo, Plato:=mdPlatoDivisor);
		dr.IsPrepared := ctrlF2SeqPrep.Done; 
		IF dr.IsPrepared THEN
			ctrlF2SeqPrep.Ack := TRUE;
			ctrlF2SeqPrep.Execute := FALSE;
		END_IF
	
	E_GEMMA.A2ParaFinCiclo,
	E_GEMMA.F1ProduccionNormal: 
		mdPickAndPlaceCarga.Mover 	:= tapas.DebeCargar(); // sectores[(NumGiros+0) MOD 8].Cargar_Tapa;
		mdEvacuador.Evacuar 		:= tapas.DebeEvacuar(); // sectores[(NumGiros+2) MOD 8].Evacuar_Tapa;
		mdPickAndPlaceDescarga.Mover:= tapas.DebeDescargar();//  sectores[(NumGiros+1) MOD 8].Descargar_Tapa;
		Execute := NOT Ack; 
 		ctrlF1Producir(		
			Alime:=mdAlimentador, 			Carga:=mdPickAndPlaceCarga, Medid:=mdMedidorTapa,
			Fotoe:=mdDetectorFotoelectrico, Induc:=mdCaptadorInductivo, Evacu:=mdEvacuador,
			Desca:=mdPickAndPlaceDescarga, 	Plato:=mdPlatoDivisor, 		Cinta:=mdCinta,
			IC:=IC, Execute:=Execute, Ack:=Ack,
			Ready=>Ready, Done=>Done, Failure=>Failure);
		dr.EndCycle := ctrlF1Producir.Done;
		dr.EndBatch := tapas.ReqNumero=tapas.ResReal;
		ctrlF1Producir.Ack := ctrlF1Producir.Done;
		ctrlF1Producir.Execute := NOT dr.EndBatch;		
		
		
	E_GEMMA.F3SecuenciaFinalizacion:
		ctrlF3SeqFin(Evacu:=mdEvacuador, Plato:=mdPlatoDivisor);
		dr.IsFinished := ctrlF3SeqFin.Done; 
		IF dr.IsFinished THEN
			ctrlF3SeqFin.Ack := TRUE;
			ctrlF3SeqFin.Execute := FALSE;
		END_IF
		
	// tener en cuenta los mandos directos
	E_GEMMA.F4VerificacionSinOrden: 
		IF fbPanel.swF4_Avanza THEN
			mdCinta.Avanza();
		ELSIF fbPanel.swF4_Retroc THEN
			mdCinta.Retrocede();
		END_IF
		
		
		
	// tener en cuenta las consignas relacionadas con F5
	E_GEMMA.F5VerificacionOrdenada : 
		mdAlimentador.Execute           := fbPanel.swF5_Ejecutar AND fbPanel.swF5_Alimentar;
		mdPickAndPlaceCarga.Execute     := fbPanel.swF5_Ejecutar AND fbPanel.swF5_Cargar;
		mdMedidorTapa.Execute           := fbPanel.swF5_Ejecutar AND fbPanel.swF5_Medir;
		mdDetectorFotoelectrico.Execute := fbPanel.swF5_Ejecutar AND fbPanel.swF5_Claridad;
		mdCaptadorInductivo.Execute     := fbPanel.swF5_Ejecutar AND fbPanel.swF5_Material;
		mdEvacuador.Execute             := fbPanel.swF5_Ejecutar AND fbPanel.swF5_Evacuar;
		mdPickAndPlaceDescarga.Execute  := fbPanel.swF5_Ejecutar AND fbPanel.swF5_Descargar;
		mdPlatoDivisor.Execute          := fbPanel.swF5_Ejecutar AND fbPanel.swF5_Girar;
		mdCinta.Situar					:= fbPanel.swF5_Situar;
		mdCinta.Transferir				:= fbPanel.swF5_Transferir;
		mdCinta.Execute					:= fbPanel.swF5_Ejecutar AND (fbPanel.swF5_Situar OR fbPanel.swF5_Transferir);
		
		mdPickAndPlaceCarga.Mover	    := TRUE; //dr.bot_Ejecutar AND fbPanel.swF5_Cargar;
		mdEvacuador.Evacuar 			:= TRUE; // fbPanel.swF5_Ejecutar AND fbPanel.swF5_Rechazar;
		mdPickAndPlaceDescarga.Mover	:= TRUE; // fbPanel.swF5_Ejecutar AND fbPanel.swF5_Descargar;

		mdAlimentador.Ack               := fbPanel.swF5_Ack AND fbPanel.swF5_Alimentar;
		mdPickAndPlaceCarga.Ack         := fbPanel.swF5_Ack AND fbPanel.swF5_Cargar;
		mdMedidorTapa.Ack               := fbPanel.swF5_Ack AND fbPanel.swF5_Medir;
		mdDetectorFotoelectrico.Ack     := fbPanel.swF5_Ack AND fbPanel.swF5_Claridad;
		mdCaptadorInductivo.Ack         := fbPanel.swF5_Ack AND fbPanel.swF5_Material;
		mdEvacuador.Ack                 := fbPanel.swF5_Ack AND fbPanel.swF5_Evacuar;
		mdPickAndPlaceDescarga.Ack      := fbPanel.swF5_Ack AND fbPanel.swF5_Descargar;
		mdPlatoDivisor.Ack              := fbPanel.swF5_Ack AND fbPanel.swF5_Girar;
		mdCinta.Ack						:= fbPanel.swF5_Ack AND (fbPanel.swF5_Situar OR fbPanel.swF5_Transferir);

	E_GEMMA.F6Probando:
		ctrlF6Prueba(		
			Alime:=mdAlimentador, 			Carga:=mdPickAndPlaceCarga, Medid:=mdMedidorTapa,
			Fotoe:=mdDetectorFotoelectrico, Induc:=mdCaptadorInductivo, Evacu:=mdEvacuador,
			Desca:=mdPickAndPlaceDescarga, 	Plato:=mdPlatoDivisor, 		Cinta:=mdCinta);
			
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="InitialConditions" Id="{6c17034c-aab7-41fb-b0b6-e85a6db67498}">
      <Declaration><![CDATA[METHOD InitialConditions : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* La estación está en condiciones iniciales si cada módulo lo está *)
InitialConditions :=
	(
		mdAlimentador.InitialConditions() AND
		mdPickAndPlaceCarga.InitialConditions() AND
		mdMedidorTapa.InitialConditions() AND 
		mdCaptadorInductivo.InitialConditions() AND
		mdDetectorFotoelectrico.InitialConditions() AND
		mdEvacuador.InitialConditions() AND
		mdPickAndPlaceDescarga.InitialConditions() AND
		mdPlatoDivisor.InitialConditions() AND
		mdCinta.InitialConditions()
	)  or dr.gmLocalHost; 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="IsStopped" Id="{63c7f49b-23e4-43c3-ac69-584bc16d9aec}">
      <Declaration><![CDATA[METHOD IsStopped : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IsStopped := 
	(
		mdAlimentador.IsStopped AND
		mdPickAndPlaceCarga.IsStopped AND
		mdMedidorTapa.IsStopped AND 
		mdCaptadorInductivo.IsStopped AND
		mdDetectorFotoelectrico.IsStopped AND
		mdEvacuador.IsStopped AND
		mdPickAndPlaceDescarga.IsStopped AND
		mdPlatoDivisor.IsStopped AND
		mdCinta.IsStopped
	); 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ProcessCycle" Id="{02e4c75f-69e3-444f-8a2e-ecad65532e26}">
      <Declaration><![CDATA[METHOD ProcessCycle : BOOL
VAR_INPUT
END_VAR

VAR
	NumSector : DINT;
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// calcular consignas en función del panel y del modo Gemma
fbPanel.ProcessCycle(gmModeActual := dr.gmModeActual, tmReinicio := dr.tmTiempoReinicio); 
dr.IC  := InitialConditions();
dr.ProcessCycle(pn:=fbPanel);
FlowControl();


// ejecutar el ciclo de cada uno de los módulos
mdAlimentador.ProcessCycle(dr:=dr, tapas:=tapas);
mdPickAndPlaceCarga.ProcessCycle(dr:=dr, tapas:=tapas);
mdMedidorTapa.ProcessCycle(dr:=dr, tapas:=tapas);	
mdDetectorFotoelectrico.ProcessCycle(dr:=dr, tapas:=tapas);
mdCaptadorInductivo.ProcessCycle(dr:=dr, tapas:=tapas);
mdEvacuador.ProcessCycle(dr:=dr, tapas:=tapas);
mdPickAndPlaceDescarga.ProcessCycle(dr:=dr, tapas:=tapas);
mdPlatoDivisor.ProcessCycle(dr:=dr, tapas:=tapas);
mdCinta.ProcessCycle(dr:=dr, tapas:=tapas);

tapas.Actualizar();

//IF mdPlatoDivisor.Execute THEN
	//girado := FALSE;
	//anguloanim := 0;
//ELSIF NOT girado THEN
	//IF mdPickAndPlaceCarga.Done THEN
	//	sectores[(NumGiros+0) MOD 8].Cargar		(pn:=fbPanel, mdCarga := mdPickAndPlaceCarga);	
	// END_IF
	//IF mdMedidorTapa.Done THEN
	//	sectores[(NumGiros+6) MOD 8].Medir		(pn:=fbPanel, mdMedid := mdMedidorTapa, cnUmbralAlta:=fbPanel.cnUmbralAlta);		
	//END_IF
	//IF  mdPlatoDivisor.Done THEN
		//girado := TRUE;
		//numGiros := numGiros + 1;
		//angulo := SEL(angulo =0, angulo-45.0, 315.0); // , angulo+45.0, 0);
		//anguloanim := 0;
	//END_IF
	
	//sectores[(NumGiros+5) MOD 8].Claridad	(pn:=fbPanel, mdFotoe := mdDetectorFotoelectrico);
	//sectores[(NumGiros+4) MOD 8].Material	(pn:=fbPanel, mdInduc := mdCaptadorInductivo);
	//sectores[(NumGiros+2) MOD 8].Evacuar 	(pn:=fbPanel, mdEvacu := mdEvacuador);
	//sectores[(NumGiros+1) MOD 8].Descargar	(pn:=fbPanel, mdDesca := mdPickAndPlaceDescarga);

//ELSIF NOT mdPlatoDivisor.Ready AND NOT mdPlatoDivisor.Done AND anguloanim >-44.0 THEN
//	anguloanim := anguloanim - 0.05;
//END_IF

(*

osCarga := (NumGiros+0) MOD 8;
PosMedid := ;
PosFotoe := ;
PosInduc := ;
PosEvacu := ;
PosDesca := ;


// actualizar el estado de la estación
IF NOT girado THEN
	sectores[PosCarga].Cargar	(pn:=fbPanel, mdCarga := mdPickAndPlaceCarga);
	sectores[PosMedid].Medir	(pn:=fbPanel, mdMedid := mdMedidorTapa, cnUmbralAlta:=fbPanel.cnUmbralAlta);
	sectores[PosFotoe].Claridad	(pn:=fbPanel, mdFotoe := mdDetectorFotoelectrico);
	sectores[PosInduc].Material	(pn:=fbPanel, mdInduc := mdCaptadorInductivo);
	sectores[PosEvacu].Evacuar 	(pn:=fbPanel, mdEvacu := mdEvacuador);
	sectores[PosDesca].Descargar(pn:=fbPanel, mdDesca := mdPickAndPlaceDescarga);
END_IF



IF mdPlatoDivisor.Done AND NOT girado THEN
	numGiros := numGiros + 1;
	girado := TRUE;
	angulo := SEL(angulo =0, angulo-45.0, 315.0); // , angulo+45.0, 0);

	IF sectores[PosEvacu].Descargar_Tapa THEN
		ProdRechazada := ProdRechazada + 1;
		
	END_IF	
END_IF
IF mdPlatoDivisor.Ready THEN
	girado := FALSE;
END_IF


*)
	
(*	
// actualizaz posición que ocupa cada módulo
PosCarga := (NumGiros+0) MOD 8;
PosMedid := (NumGiros+6) MOD 8;
PosFotoe := (NumGiros+5) MOD 8;
PosInduc := (NumGiros+4) MOD 8;
PosEvacu := (NumGiros+2) MOD 8;
PosDesca := (NumGiros+1) MOD 8;
*)

// controlar el flujo de la estación en función del estado Gemma y las consignas del panel

]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>