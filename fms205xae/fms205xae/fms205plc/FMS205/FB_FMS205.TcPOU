<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_FMS205" Id="{a261f573-1402-443e-9bab-e88e0bf02070}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_FMS205
VAR_INPUT
	IC: 		BOOL := FALSE; 	// todos los módulos están en condiciones iniciales
    Execute: BOOL;
	Ack : BOOL;
END_VAR
VAR_OUTPUT
	Ready: BOOL;
	Failure: BOOL;
	Done: BOOL;	
END_VAR	

//VAR_INPUT
//	MaximoTiempoRespuesta: TIME := T#5S;
//	ManiobrasDeseadas: UINT :=1; // POST15 AÑADIDO VALOR POR DEFECTO
//END_VAR

VAR_OUTPUT
	ManiobrasRealizadas: UINT := 0;
	ManiobrasPendientes: UINT;
	
	Preparada : BOOL := TRUE;	// la estación está preparada después de encender
	FinCiclo: 	BOOL := FALSE;	// una pieza se ha completado
	FinTarea: 	BOOL := FALSE;	// el lote se ha completado
	Fallo: 		BOOL := FALSE;	// al menos un módulo ha fallado
    Finalizada: BOOL := TRUE;	// la estación está lista para apagarse    	
END_VAR

VAR
	// controladores de la máquina, la función de producción y la guía GEMMA 
	dr						: FB_Director;
	numGiros : DINT := 0;
	angulo	 : REAL := 0.0;
	girado	: BOOL := FALSE;
	sectores : ARRAY [0..7] OF FB_Sector;
	
	// módulos de la FMS205
	mdAlimentador			: FB_Alimentador			:= (dr:=dr, ID := 1, Name := 'Alimentador');
	mdPickAndPlaceCarga 	: FB_PickAndPlace			:= (dr:=dr, ID := 2, Name := 'Carga');
	mdMedidorTapa			: FB_MedidorTapa			:= (dr:=dr, ID := 3, Name := 'Medidor');
	mdCaptadorInductivo 	: FB_CaptadorInductivo		:= (dr:=dr, ID := 4, Name :=  'Inductivo');
	mdDetectorFotoelectrico : FB_DetectorFotoelectrico	:= (dr:=dr, ID := 5, Name :=  'Fotoeléctrico');
	mdEvacuador			 	: FB_Evacuador				:= (dr:=dr, ID := 6, Name :=  'Evacuador');
	mdPickAndPlaceDescarga 	: FB_PickAndPlace			:= (dr:=dr, ID := 7, Name :=  'Descarga');
	mdPlatoDivisor			: FB_PlatoDivisor			:= (dr:=dr, ID := 8, Name :=  'Plato');
	mdCinta					: FB_Cinta					:= (dr:=dr, ID := 9, Name :=  'Cinta');
	
	fbPanel					: FB_Panel := (dr := dr);	
	fbFMS205_Producir_SFC	: FB_FMS205_SFC;

	

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//fbPanel.ProcessCycle(dr:=dr);
dr.ProcessCycle(
	pn := fbPanel,
	IC := InitialConditions(),
	Fallo := FALSE,
	FinCiclo := FALSE,
	FinTarea := FALSE,
	Preparada  := TRUE,
	Finalizada := TRUE);

IF fbPanel.cnF4_Planta THEN
	//F5VerificacionOrdenada();
	//F4VerificacionSinOrden();
	;
ELSIF dr.bot_Empezar THEN
	//F1ProduccionNormal();
	;
	(*
ELSE
	fbPanel(gm:=gm);
	IC:=InitialConditions();
	Preparada := TRUE; // PENDIENTE SI LA ESTACIÓN NECESITA UNA SECUENCIA DE PREPARACIÓN 
	
	
	FinCiclo := 		(* Todos los módulos han terminado su parte del ciclo *)
		mdAlimentador.Done AND
		mdPickAndPlaceCarga.Done AND
		mdMedidorTapa.Done AND
		mdCaptadorInductivo.Done AND
		mdDetectorFotoelectrico.Done AND
		mdEvacuador.Done AND
		mdPickAndPlaceDescarga.Done AND
		mdPlatoDivisor.Done AND
		mdCinta.Done;
	
	IF FinCiclo THEN	
		// Todos los módulos han terminado su secuencia de producir
		// TODO SÓLO SE PUEDE CONTAR UNA TAPA HECHA SI NO SE HA RECHAZADO Y SI SE HA METIDO EN EL CARRO
		ManiobrasRealizadas := ManiobrasRealizadas + 1;
		// POAST15  ManiobrasPendientes := ManiobrasDeseadas - ManiobrasRealizadas;	
		// Añadir aquí LA LÓGICA DEL FINAL DE CICLO
		// p. ej. actualización del plato con los resultados de sensores  	
	END_IF
	ManiobrasPendientes := ManiobrasDeseadas - ManiobrasRealizadas; // POST15 hay que calcular siempre las maniobras pendientes
	
	FinTarea := ManiobrasPendientes = 0; 	// Se finaliza la tarea si no quedan maniobras pendientes
	
	Fallo:=									// La estaciónn está en fallo si al menos un módulo ha fallado
		mdAlimentador.Failure OR
		mdPickAndPlaceCarga.Failure OR
		mdMedidorTapa.Failure OR 
		mdCaptadorInductivo.Failure OR
		mdDetectorFotoelectrico.Failure OR
		mdEvacuador.Failure OR
		mdPickAndPlaceDescarga.Failure OR
		mdCinta.Failure; 
	
		
	Finalizada := TRUE;	 // PENDIENTE SI LA ESTACIÓN NECESITA UNA SECUENCIA DE PREPARACIÓN 
	Director();
	
	Execute :=  (* El coordinador indica que hay empezar *)
		(gm.ModeActual = E_GEMMA.F6Probando AND dr.bot_Ejecutar) OR // td.Execute) OR
		(gm.ModeActual <> E_GEMMA.F6Probando AND
			(
				(gm.ModeActual = E_GEMMA.A2ParaFinCiclo) OR 
				(gm.ModeActual = E_GEMMA.A3ParadaEstado) OR 
				(gm.ModeActual = E_GEMMA.F1ProduccionNormal) OR 
				(gm.ModeActual = E_GEMMA.F2SecuenciaPreparacion) OR 
				(gm.ModeActual = E_GEMMA.F3SecuenciaFinalizacion) OR 
				(gm.ModeActual = E_GEMMA.F5VerificacionOrdenada) OR 
				(gm.ModeActual = E_GEMMA.F6Probando) OR 
				(gm.ModeActual = E_GEMMA.D3ProducirConFallos)
			) 
		);
			
	
	Ack := // Notificar a los módulos que ya pueden volver al inicio
		(gm.ModeActual = E_GEMMA.F6Probando AND dr.bot_Continuar) OR 
		(gm.ModeActual <> E_GEMMA.F6Probando AND FinCiclo);
	// TODO SI HAY FIN DE CICLO HAY QUE HACER UN MONTÓN DE COSAS, POR EJEMPLO, ACTUALIZAR EL PLATO CON EL SENSOR FOTOELÉCTRICO
	
	
	mdEvacuador.Evacuar := TRUE; // TODO PENDIENTE DECISIÓN DE EVACUAR O NO EN FUNCIÓN DEL TIPO DE TAPA
	mdPickAndPlaceCarga.Mover := TRUE;
	mdPickAndPlaceDescarga.Mover := TRUE;
	

	// TODO CARGA Y DESCARGA TENGAN UNA OPCION DE NO HACER NADA
	
	IF dr.ModeActual = E_GEMMA.F5VerificacionOrdenada THEN //IF gm.ModeActual = E_GEMMA.F6Probando THEN
		; // TestControl();
	ELSE
		fbFMS205_Producir_SFC(		
			mdAlimentador 			:= mdAlimentador,
			mdPickAndPlaceCarga 	:= mdPickAndPlaceCarga,
			mdMedidorTapa			:= mdMedidorTapa,
			mdCaptadorInductivo 	:= mdCaptadorInductivo,
			mdDetectorFotoelectrico := mdDetectorFotoelectrico,
			mdEvacuador			 	:= mdEvacuador,
			mdPickAndPlaceDescarga 	:= mdPickAndPlaceDescarga,
			mdPlatoDivisor			:= mdPlatoDivisor,
			mdCinta					:= mdCinta,
			IC:=IC, Execute:=Execute, Ack:=Ack,
			Ready=>Ready, Done=>Done, Failure=>Failure);
	
	END_IF
	*)
	
END_IF
ProcessCycle();

]]></ST>
    </Implementation>
    <Method Name="ControlFlow" Id="{80fd4987-b1ea-4ff4-96de-09984f5bd65d}">
      <Declaration><![CDATA[METHOD ControlFlow : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE dr.gmModeActual OF
	E_GEMMA.F1ProduccionNormal: // invocar al grafcet de producción
 		fbFMS205_Producir_SFC(		
			mdAlimentador 			:= mdAlimentador,
			mdPickAndPlaceCarga 	:= mdPickAndPlaceCarga,
			mdMedidorTapa			:= mdMedidorTapa,
			mdCaptadorInductivo 	:= mdCaptadorInductivo,
			mdDetectorFotoelectrico := mdDetectorFotoelectrico,
			mdEvacuador			 	:= mdEvacuador,
			mdPickAndPlaceDescarga 	:= mdPickAndPlaceDescarga,
			mdPlatoDivisor			:= mdPlatoDivisor,
			mdCinta					:= mdCinta,
			IC:=IC, Execute:=TRUE, Ack:=Ack,
			Ready=>Ready, Done=>Done, Failure=>Failure);
	
	E_GEMMA.F4VerificacionSinOrden: // tener en cuenta los mandos directos
		IF fbPanel.swF4_Avanza THEN
			mdCinta.Avanza();
		ELSIF fbPanel.swF4_Retroc THEN
			mdCinta.Retrocede();
		END_IF
		
	E_GEMMA.F5VerificacionOrdenada : // tener en cuenta las consignas relacionadas con F5
		mdAlimentador.Execute           := fbPanel.swF5_Ejecutar AND fbPanel.swF5_Alimentar;
		mdPickAndPlaceCarga.Execute     := fbPanel.swF5_Ejecutar AND fbPanel.swF5_Cargar;
		mdMedidorTapa.Execute           := fbPanel.swF5_Ejecutar AND fbPanel.swF5_Medir;
		mdDetectorFotoelectrico.Execute := fbPanel.swF5_Ejecutar AND fbPanel.swF5_Claridad;
		mdCaptadorInductivo.Execute     := fbPanel.swF5_Ejecutar AND fbPanel.swF5_Material;
		mdEvacuador.Execute             := fbPanel.swF5_Ejecutar AND fbPanel.swF5_Evacuar;
		mdPickAndPlaceDescarga.Execute  := fbPanel.swF5_Ejecutar AND fbPanel.swF5_Descargar;
		mdPlatoDivisor.Execute          := fbPanel.swF5_Ejecutar AND fbPanel.swF5_Girar;
		mdCinta.Situar					:= fbPanel.swF5_Situar;
		mdCinta.Transferir				:= fbPanel.swF5_Transferir;
		mdCinta.Execute					:= fbPanel.swF5_Ejecutar AND (fbPanel.swF5_Situar OR fbPanel.swF5_Transferir);
		
		mdPickAndPlaceCarga.Mover	    := TRUE; //dr.bot_Ejecutar AND fbPanel.swF5_Cargar;
		mdEvacuador.Evacuar 			:= TRUE; // fbPanel.swF5_Ejecutar AND fbPanel.swF5_Rechazar;
		mdPickAndPlaceDescarga.Mover	:= TRUE; // fbPanel.swF5_Ejecutar AND fbPanel.swF5_Descargar;

		mdAlimentador.Ack               := fbPanel.swF5_Ack AND fbPanel.swF5_Alimentar;
		mdPickAndPlaceCarga.Ack         := fbPanel.swF5_Ack AND fbPanel.swF5_Cargar;
		mdMedidorTapa.Ack               := fbPanel.swF5_Ack AND fbPanel.swF5_Medir;
		mdDetectorFotoelectrico.Ack     := fbPanel.swF5_Ack AND fbPanel.swF5_Claridad;
		mdCaptadorInductivo.Ack         := fbPanel.swF5_Ack AND fbPanel.swF5_Material;
		mdEvacuador.Ack                 := fbPanel.swF5_Ack AND fbPanel.swF5_Evacuar;
		mdPickAndPlaceDescarga.Ack      := fbPanel.swF5_Ack AND fbPanel.swF5_Descargar;
		mdPlatoDivisor.Ack              := fbPanel.swF5_Ack AND fbPanel.swF5_Girar;
		mdCinta.Ack						:= fbPanel.swF5_Ack AND (fbPanel.swF5_Situar OR fbPanel.swF5_Transferir);		
END_CASE
	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="InitialConditions" Id="{6c17034c-aab7-41fb-b0b6-e85a6db67498}">
      <Declaration><![CDATA[METHOD InitialConditions : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* La estación está en condiciones iniciales si cada módulo lo está *)
InitialConditions :=
	(
		mdAlimentador.InitialConditions() AND
		mdPickAndPlaceCarga.InitialConditions() AND
		mdMedidorTapa.InitialConditions() AND 
		mdCaptadorInductivo.InitialConditions() AND
		mdDetectorFotoelectrico.InitialConditions() AND
		mdEvacuador.InitialConditions() AND
		mdPickAndPlaceDescarga.InitialConditions() AND
		mdPlatoDivisor.InitialConditions() AND
		mdCinta.InitialConditions()
	); 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ProcessCycle" Id="{02e4c75f-69e3-444f-8a2e-ecad65532e26}">
      <Declaration><![CDATA[METHOD ProcessCycle : BOOL
VAR_INPUT
END_VAR

VAR
	NumSector : DINT;
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// calcular consignas en función del panel y del modo Gemma
fbPanel.ProcessCycle(gmModeActual := dr.gmModeActual); 

// calcular el nuevo modo GEMMA en funicón de las consignas del panel
dr.ProcessCycle(pn:=fbPanel,
	IC := InitialConditions(),
	Fallo := FALSE,
	FinCiclo := FALSE,
	FinTarea := FALSE,
	Preparada  := TRUE,
	Finalizada := TRUE);

// controlar el flujo de la estación en función del estado Gemma y las consignas del panel
ControlFlow();

// ejecutar el ciclo de cada uno de los módulos
mdAlimentador.ProcessCycle(dr:=dr);
mdPickAndPlaceCarga.ProcessCycle(dr:=dr);
mdMedidorTapa.ProcessCycle(dr:=dr);	
mdDetectorFotoelectrico.ProcessCycle(dr:=dr);
mdCaptadorInductivo.ProcessCycle(dr:=dr);
mdEvacuador.ProcessCycle(dr:=dr);
mdPickAndPlaceDescarga.ProcessCycle(dr:=dr);
mdPlatoDivisor.ProcessCycle(dr:=dr);


// actualizar el estado de la estación
IF NOT girado THEN
	// Actualizar la posición de carga
	NumSector := (NumGiros+0) MOD 8;
	sectores[NumSector].Cargar(mdCarga:=mdPickAndPlaceCarga);
	
	// Actualizar la posición del medidor
	NumSector := (NumGiros+6) MOD 8;
	sectores[NumSector].Medir(mdMedid:=mdMedidorTapa, 
								cnUmbralAlta:=fbPanel.cnUmbralAlta);
	
	// Actualizar la poisición del fotoeléctrico
	NumSector := (NumGiros+5) MOD 8;
	sectores[NumSector].Claridad(mdFotoe:=mdDetectorFotoelectrico);

	// Actualizar la posición del inductivo
	NumSector := (NumGiros+4) MOD 8;
	sectores[NumSector].Material(mdInduc:=mdCaptadorInductivo);

	// Actualizar la posición del evaccuador
	NumSector := (NumGiros+2) MOD 8;
	sectores[NumSector].Evacuar(fbEvacu:=mdEvacuador);
	
	// Actualizar la posición de descarga
 	NumSector := (NumGiros+1) MOD 8;
	sectores[NumSector].Descargar(mdDesca:=mdPickAndPlaceDescarga);
END_IF

FOR i := 0 TO 8 DO
	sectores[i].ActualizarUi(pn:=fbPanel);
END_FOR

IF mdPlatoDivisor.Done AND NOT girado THEN
	numGiros := numGiros + 1;
	girado := TRUE;
	angulo := SEL(angulo =0, angulo-45.0, 315.0); // , angulo+45.0, 0);	
END_IF
IF mdPlatoDivisor.Ready THEN
	girado := FALSE;
END_IF

mdCinta.ProcessCycle(dr:=dr);

]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>