<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_FMS205" Id="{a261f573-1402-443e-9bab-e88e0bf02070}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_FMS205
VAR_INPUT
	IC: 		BOOL := FALSE; 	// todos los módulos están en condiciones iniciales
    Execute: BOOL;
	Ack : BOOL;
END_VAR
VAR_OUTPUT
	Ready: BOOL;
	Failure: BOOL;
	Done: BOOL;	
END_VAR	

//VAR_INPUT
//	MaximoTiempoRespuesta: TIME := T#5S;
//	ManiobrasDeseadas: UINT :=1; // POST15 AÑADIDO VALOR POR DEFECTO
//END_VAR

VAR_OUTPUT
	ManiobrasRealizadas: UINT := 0;
	ManiobrasPendientes: UINT;
	
	Preparada : BOOL := TRUE;	// la estación está preparada después de encender
	FinCiclo: 	BOOL := FALSE;	// una pieza se ha completado
	FinTarea: 	BOOL := FALSE;	// el lote se ha completado
	Fallo: 		BOOL := FALSE;	// al menos un módulo ha fallado
    Finalizada: BOOL := TRUE;	// la estación está lista para apagarse    	
END_VAR

VAR
	// controladores de la máquina, la función de producción y la guía GEMMA 
	dr						: FB_Director;
	numGiros : DINT := 0;
	angulo	 : REAL := 0.0;
	girado	: BOOL := FALSE;
	sectores : ARRAY [0..7] OF FB_Sector;
	
	// módulos de la FMS205
	mdAlimentador			: FB_Alimentador			:= (dr:=dr, ID := 1, Name := 'Alimentador');
	mdPickAndPlaceCarga 	: FB_PickAndPlace			:= (dr:=dr, ID := 2, Name := 'Carga');
	mdMedidorTapa			: FB_MedidorTapa			:= (dr:=dr, ID := 3, Name := 'Medidor');
	mdCaptadorInductivo 	: FB_CaptadorInductivo		:= (dr:=dr, ID := 4, Name :=  'Inductivo');
	mdDetectorFotoelectrico : FB_DetectorFotoelectrico	:= (dr:=dr, ID := 5, Name :=  'Fotoeléctrico');
	mdEvacuador			 	: FB_Evacuador				:= (dr:=dr, ID := 6, Name :=  'Evacuador');
	mdPickAndPlaceDescarga 	: FB_PickAndPlace			:= (dr:=dr, ID := 7, Name :=  'Descarga');
	mdPlatoDivisor			: FB_PlatoDivisor			:= (dr:=dr, ID := 8, Name :=  'Plato');
	mdCinta					: FB_Cinta					:= (dr:=dr, ID := 9, Name :=  'Cinta');
	
	fbPanel					: FB_Panel := (dr := dr);	
	fbFMS205_Producir_SFC	: FB_FMS205_SFC;

	

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[dr.ProcessCycle(
	IC := TRUE, // InitialConditions()
	Fallo := FALSE,
	FinCiclo := FALSE,
	FinTarea := FALSE,
	Preparada  := TRUE,
	Finalizada := TRUE);

IF dr.bot_Funcion THEN
	F5VerificacionOrdenada();
ELSIF dr.bot_Empezar THEN
	F1ProduccionNormal();
	(*
ELSE
	fbPanel(gm:=gm);
	IC:=InitialConditions();
	Preparada := TRUE; // PENDIENTE SI LA ESTACIÓN NECESITA UNA SECUENCIA DE PREPARACIÓN 
	
	
	FinCiclo := 		(* Todos los módulos han terminado su parte del ciclo *)
		mdAlimentador.Done AND
		mdPickAndPlaceCarga.Done AND
		mdMedidorTapa.Done AND
		mdCaptadorInductivo.Done AND
		mdDetectorFotoelectrico.Done AND
		mdEvacuador.Done AND
		mdPickAndPlaceDescarga.Done AND
		mdPlatoDivisor.Done AND
		mdCinta.Done;
	
	IF FinCiclo THEN	
		// Todos los módulos han terminado su secuencia de producir
		// TODO SÓLO SE PUEDE CONTAR UNA TAPA HECHA SI NO SE HA RECHAZADO Y SI SE HA METIDO EN EL CARRO
		ManiobrasRealizadas := ManiobrasRealizadas + 1;
		// POAST15  ManiobrasPendientes := ManiobrasDeseadas - ManiobrasRealizadas;	
		// Añadir aquí LA LÓGICA DEL FINAL DE CICLO
		// p. ej. actualización del plato con los resultados de sensores  	
	END_IF
	ManiobrasPendientes := ManiobrasDeseadas - ManiobrasRealizadas; // POST15 hay que calcular siempre las maniobras pendientes
	
	FinTarea := ManiobrasPendientes = 0; 	// Se finaliza la tarea si no quedan maniobras pendientes
	
	Fallo:=									// La estaciónn está en fallo si al menos un módulo ha fallado
		mdAlimentador.Failure OR
		mdPickAndPlaceCarga.Failure OR
		mdMedidorTapa.Failure OR 
		mdCaptadorInductivo.Failure OR
		mdDetectorFotoelectrico.Failure OR
		mdEvacuador.Failure OR
		mdPickAndPlaceDescarga.Failure OR
		mdCinta.Failure; 
	
		
	Finalizada := TRUE;	 // PENDIENTE SI LA ESTACIÓN NECESITA UNA SECUENCIA DE PREPARACIÓN 
	Director();
	
	Execute :=  (* El coordinador indica que hay empezar *)
		(gm.ModeActual = E_GEMMA.F6Probando AND dr.bot_Ejecutar) OR // td.Execute) OR
		(gm.ModeActual <> E_GEMMA.F6Probando AND
			(
				(gm.ModeActual = E_GEMMA.A2ParaFinCiclo) OR 
				(gm.ModeActual = E_GEMMA.A3ParadaEstado) OR 
				(gm.ModeActual = E_GEMMA.F1ProduccionNormal) OR 
				(gm.ModeActual = E_GEMMA.F2SecuenciaPreparacion) OR 
				(gm.ModeActual = E_GEMMA.F3SecuenciaFinalizacion) OR 
				(gm.ModeActual = E_GEMMA.F5VerificacionOrdenada) OR 
				(gm.ModeActual = E_GEMMA.F6Probando) OR 
				(gm.ModeActual = E_GEMMA.D3ProducirConFallos)
			) 
		);
			
	
	Ack := // Notificar a los módulos que ya pueden volver al inicio
		(gm.ModeActual = E_GEMMA.F6Probando AND dr.bot_Continuar) OR 
		(gm.ModeActual <> E_GEMMA.F6Probando AND FinCiclo);
	// TODO SI HAY FIN DE CICLO HAY QUE HACER UN MONTÓN DE COSAS, POR EJEMPLO, ACTUALIZAR EL PLATO CON EL SENSOR FOTOELÉCTRICO
	
	
	mdEvacuador.Evacuar := TRUE; // TODO PENDIENTE DECISIÓN DE EVACUAR O NO EN FUNCIÓN DEL TIPO DE TAPA
	mdPickAndPlaceCarga.Mover := TRUE;
	mdPickAndPlaceDescarga.Mover := TRUE;
	

	// TODO CARGA Y DESCARGA TENGAN UNA OPCION DE NO HACER NADA
	
	IF dr.ModeActual = E_GEMMA.F5VerificacionOrdenada THEN //IF gm.ModeActual = E_GEMMA.F6Probando THEN
		; // TestControl();
	ELSE
		fbFMS205_Producir_SFC(		
			mdAlimentador 			:= mdAlimentador,
			mdPickAndPlaceCarga 	:= mdPickAndPlaceCarga,
			mdMedidorTapa			:= mdMedidorTapa,
			mdCaptadorInductivo 	:= mdCaptadorInductivo,
			mdDetectorFotoelectrico := mdDetectorFotoelectrico,
			mdEvacuador			 	:= mdEvacuador,
			mdPickAndPlaceDescarga 	:= mdPickAndPlaceDescarga,
			mdPlatoDivisor			:= mdPlatoDivisor,
			mdCinta					:= mdCinta,
			IC:=IC, Execute:=Execute, Ack:=Ack,
			Ready=>Ready, Done=>Done, Failure=>Failure);
	
	END_IF
	*)
	
END_IF
ProcessCycle();

]]></ST>
    </Implementation>
    <Method Name="F1ProduccionNormal" Id="{7ca323ea-768d-4b20-9a60-81cfe805fdbf}">
      <Declaration><![CDATA[METHOD F1ProduccionNormal : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbFMS205_Producir_SFC(		

	mdAlimentador 			:= mdAlimentador,
	mdPickAndPlaceCarga 	:= mdPickAndPlaceCarga,
	mdMedidorTapa			:= mdMedidorTapa,
	mdCaptadorInductivo 	:= mdCaptadorInductivo,
	mdDetectorFotoelectrico := mdDetectorFotoelectrico,
	mdEvacuador			 	:= mdEvacuador,
	mdPickAndPlaceDescarga 	:= mdPickAndPlaceDescarga,
	mdPlatoDivisor			:= mdPlatoDivisor,
	mdCinta					:= mdCinta,
	IC:=IC, Execute:=TRUE, Ack:=Ack,
	Ready=>Ready, Done=>Done, Failure=>Failure);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="F5VerificacionOrdenada" Id="{cc903692-dfc3-4295-9550-eca76703506f}">
      <Declaration><![CDATA[METHOD F5VerificacionOrdenada : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[mdAlimentador.Execute           := dr.bot_Ejecutar AND dr.fun_Alimentar;

mdPickAndPlaceCarga.Mover	    := dr.bot_Ejecutar AND dr.fun_Cargar;
mdPickAndPlaceCarga.Execute     := dr.bot_Ejecutar AND dr.fun_Cargar;

mdMedidorTapa.Execute           := dr.bot_Ejecutar AND dr.fun_Altura;

mdDetectorFotoelectrico.Execute := dr.bot_Ejecutar AND dr.fun_Color;

mdCaptadorInductivo.Execute     := dr.bot_Ejecutar AND dr.fun_Material;

mdEvacuador.Evacuar 			:= dr.bot_Ejecutar AND dr.fun_Rechazar;
mdEvacuador.Execute             := dr.bot_Ejecutar AND dr.fun_Rechazar;

mdPickAndPlaceDescarga.Mover	:= dr.bot_Ejecutar AND dr.fun_Descargar;
mdPickAndPlaceDescarga.Execute  := dr.bot_Ejecutar AND dr.fun_Descargar;

mdPlatoDivisor.Execute          := dr.bot_Ejecutar AND dr.fun_Girar;

mdCinta.Situar					:= dr.fun_Situar;
mdCinta.Transferir				:= dr.fun_Transferir;
mdCinta.Execute					:= dr.bot_Ejecutar AND (dr.fun_Situar OR dr.fun_Transferir);


mdAlimentador.Ack               := dr.bot_Continuar AND dr.fun_Alimentar;
mdPickAndPlaceCarga.Ack         := dr.bot_Continuar AND dr.fun_Cargar;
mdMedidorTapa.Ack               := dr.bot_Continuar AND dr.fun_Altura;
mdDetectorFotoelectrico.Ack     := dr.bot_Continuar AND dr.fun_Color;
mdCaptadorInductivo.Ack         := dr.bot_Continuar AND dr.fun_Material;
mdEvacuador.Ack                 := dr.bot_Continuar AND dr.fun_Rechazar;
mdPickAndPlaceDescarga.Ack      := dr.bot_Continuar AND dr.fun_Descargar;
mdPlatoDivisor.Ack              := dr.bot_Continuar AND dr.fun_Girar;
mdCinta.Ack						:= dr.bot_Continuar AND (dr.fun_Situar OR dr.fun_Transferir);]]></ST>
      </Implementation>
    </Method>
    <Method Name="InitialConditions" Id="{6c17034c-aab7-41fb-b0b6-e85a6db67498}">
      <Declaration><![CDATA[METHOD InitialConditions : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* La estación está en condiciones iniciales si cada módulo lo está *)
InitialConditions :=
	(
		mdAlimentador.InitialConditions() AND
		mdPickAndPlaceCarga.InitialConditions() AND
		mdMedidorTapa.InitialConditions() AND 
		mdCaptadorInductivo.InitialConditions() AND
		mdDetectorFotoelectrico.InitialConditions() AND
		mdEvacuador.InitialConditions() AND
		mdPickAndPlaceDescarga.InitialConditions() AND
		mdPlatoDivisor.InitialConditions() AND
		mdCinta.InitialConditions()
 // TODO AND CINTA.INITIAL...
	); 
	// OR (fbDirector.Modo=E_GEMMA.F6Probando); // POST15 PARA FORZAR CONDICIONES INICIALES SIN HARDWARE !!! eliminar
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ProcessCycle" Id="{02e4c75f-69e3-444f-8a2e-ecad65532e26}">
      <Declaration><![CDATA[METHOD ProcessCycle : BOOL
VAR_INPUT
END_VAR

VAR
	NumSector : DINT;
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[mdAlimentador.ProcessCycle(dr:=dr);

mdPickAndPlaceCarga.ProcessCycle(dr:=dr);
IF mdPickAndPlaceCarga.Done AND NOT girado THEN
	NumSector := (NumGiros+0) MOD 8;
	sectores[NumSector].Cargar(dr:=dr, mdCarga:=mdPickAndPlaceCarga);
END_IF

mdMedidorTapa.ProcessCycle(dr:=dr);	// Revisar es medidor
IF mdMedidorTapa.Done AND NOT girado THEN
	NumSector := (NumGiros+6) MOD 8;
	sectores[NumSector].Medir(dr:= dr, mdMedid:=mdMedidorTapa); 
END_IF

mdDetectorFotoelectrico.ProcessCycle(dr:=dr);
IF mdDetectorFotoelectrico.Done AND NOT girado THEN
	NumSector := (NumGiros+5) MOD 8;
	sectores[NumSector].Claridad(dr:=dr, mdFotoe:=mdDetectorFotoelectrico); 
END_IF

mdCaptadorInductivo.ProcessCycle(dr:=dr);
IF mdCaptadorInductivo.Done AND NOT girado THEN
	NumSector := (NumGiros+4) MOD 8;
	sectores[NumSector].Material(dr:=dr, mdInduc:=mdCaptadorInductivo); 
END_IF


mdEvacuador.ProcessCycle(dr:=dr);

mdPickAndPlaceDescarga.ProcessCycle(dr:=dr);



mdPlatoDivisor.ProcessCycle(dr:=dr);
IF mdPlatoDivisor.Done AND NOT girado THEN
	numGiros := numGiros + 1;
	girado := TRUE;
	angulo := SEL(angulo =0, angulo-45.0, 315.0); // , angulo+45.0, 0);	
END_IF
IF mdPlatoDivisor.Ready THEN
	girado := FALSE;
END_IF

mdCinta.ProcessCycle(dr:=dr);

FOR i := 0 TO 8 do
	sectores[i].UpdateUi(dr:=dr);
END_FOR]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>