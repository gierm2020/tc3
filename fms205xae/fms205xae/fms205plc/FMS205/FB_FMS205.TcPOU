<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_FMS205" Id="{a261f573-1402-443e-9bab-e88e0bf02070}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_FMS205
VAR_INPUT
	MaximoTiempoRespuesta: TIME := T#5S;
	ManiobrasDeseadas: UINT;
END_VAR

VAR_OUTPUT
	ManiobrasRealizadas: UINT := 0;
	ManiobrasPendientes: UINT;
	
	IC: 		BOOL := FALSE; 	// todos los módulos están en condiciones iniciales
    Preparada : BOOL := TRUE;	// la estación está preparada después de encender
	FinCiclo: 	BOOL := FALSE;	// una pieza se ha completado
	FinTarea: 	BOOL := FALSE;	// el lote se ha completado
	Fallo: 		BOOL := FALSE;	// al menos un módulo ha fallado
    Finalizada: BOOL := TRUE;	// la estación está lista para apagarse    	
END_VAR

VAR
	// instrucciones de entrada a los controladores de los módulos
	fbDirector				: FB_Director;
	ctInp 					: S_ControllerInput;
	
	// módulos de la FMS205
	mdAlimentador			: FB_Alimentador			(ID:=0, MRT:=MaximoTiempoRespuesta);
	mdPickAndPlaceCarga 	: FB_PickAndPlace			(ID:=1, MRT:=MaximoTiempoRespuesta);
	mdMedidorTapa			: FB_MedidorTapa			(ID:=3, MRT:=MaximoTiempoRespuesta);
	mdCaptadorInductivo 	: FB_CaptadorInductivo		(ID:=4, MRT:=MaximoTiempoRespuesta);
	mdDetectorFotoelectrico : FB_DetectorFotoelectrico	(ID:=5, MRT:=MaximoTiempoRespuesta);
	mdEvacuador			 	: FB_Evacuador				(ID:=7, MRT:=MaximoTiempoRespuesta);
	mdPickAndPlaceDescarga 	: FB_PickAndPlace			(ID:=8, MRT:=MaximoTiempoRespuesta);
	mdPlatoDivisor			: FB_PlatoDivisor			(ID:=9, MRT:=MaximoTiempoRespuesta);
	
	// controladores de la máquina, la función de producción y la guía GEMMA 
	fbPanel					: FB_Panel;
	//fbFMS205_SFC			: FB_FMS205_SFC;
	fbFMS205_Producir_SFC	: FB_FMS205_Producir_SFC;

	// pendiente renombrar - variables en interfaz de usuario
	Execute : BOOL;
	Ack : BOOL;

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbPanel();


IC:=				(* La estación está en condiciones iniciales si cada módulo lo está *)
	mdAlimentador.ctOut.IC AND
	mdPickAndPlaceCarga.ctOut.IC AND
	mdMedidorTapa.ctOut.IC AND 
	mdCaptadorInductivo.ctOut.IC AND
	mdDetectorFotoelectrico.ctOut.IC AND
	mdEvacuador.ctOut.IC AND
	mdPickAndPlaceDescarga.ctOut.IC; 

	
Preparada := TRUE; // PENDIENTE SI LA ESTACIÓN NECESITA UNA SECUENCIA DE PREPARACIÓN 


FinCiclo := 		(* Todos los módulos han terminado su parte del ciclo *)
	mdAlimentador.ctOut.Done AND
	mdPickAndPlaceCarga.ctOut.Done AND
	mdMedidorTapa.ctOut.Done AND
	mdCaptadorInductivo.ctOut.Done AND
	mdDetectorFotoelectrico.ctOut.Done AND
	mdEvacuador.ctOut.Done AND
	mdPickAndPlaceDescarga.ctOut.Done AND
	mdPlatoDivisor.ctOut.Done;

IF FinCiclo THEN	
	// Todos los módulos han terminado su secuencia de producir
	ManiobrasRealizadas := ManiobrasRealizadas + 1;
	ManiobrasPendientes := ManiobrasDeseadas - ManiobrasRealizadas;	
	// Añadir aquí LA LÓGICA DEL FINAL DE CICLO
	// p. ej. actualización del plato con los resultados de sensores  	
END_IF


FinTarea := ManiobrasPendientes = 0; 	// Se finaliza la tarea si no quedan maniobras pendientes

Fallo:=									// La estaciónn está en fallo si al menos un módulo ha fallado
	mdAlimentador.ctOut.Fail OR
	mdPickAndPlaceCarga.ctOut.Fail OR
	mdMedidorTapa.ctOut.Fail OR 
	mdCaptadorInductivo.ctOut.Fail OR
	mdDetectorFotoelectrico.ctOut.Fail OR
	mdEvacuador.ctOut.Fail OR
	mdPickAndPlaceDescarga.ctOut.Fail; 

	
Finalizada := TRUE;	 // PENDIENTE SI LA ESTACIÓN NECESITA UNA SECUENCIA DE PREPARACIÓN 

fbDirector(
	fbPanel 	:= fbPanel,
	IC 			:= IC, 
	Preparada 	:= Preparada,
	FinCiclo	:= FinCiclo,
	FinTarea	:= FinTarea,
	Fallo		:= Fallo,
	Finalizada	:= Finalizada);
 

// IF fbDirector.Modo = E_Gemma.A6Inicializando THEN
// Informar la estructura ctInp que se copiará a todos y cada uno de los 

ctInp.Execute :=  (* El coordinador indica que hay empezar *)
		((fbDirector.Modo = E_GEMMA.A2ParaFinCiclo) OR 
	 	(fbDirector.Modo = E_GEMMA.A3ParadaEstado) OR 
	 	(fbDirector.Modo = E_GEMMA.F1ProduccionNormal) OR 
	 	(fbDirector.Modo = E_GEMMA.F2SecuenciaPreparacion) OR 
	 	(fbDirector.Modo = E_GEMMA.F3SecuenciaFinalizacion) OR 
	 	(fbDirector.Modo = E_GEMMA.F5VerificacionOrdenada) OR 
	 	(fbDirector.Modo = E_GEMMA.F6Probando) OR 
	 	(fbDirector.Modo = E_GEMMA.D3ProducirConFallos))
	; // AND NOT IC;

ctInp.Ack := FinCiclo; 					// Notificar a los módulos que ya pueden volver al inicio

ctInp.Manual := (* Establece modo de funcionamiento manual *) 
	(fbDirector.Modo = E_GEMMA.F4VerificacionSinOrden);
	
ctInp.Pause := (* Pausa la ejecucion de la funcionalidad  *)
	(fbDirector.Modo = E_GEMMA.A3ParadaEstado) OR 
	(fbDirector.Modo = E_GEMMA.A4ParadaObtenida) OR 
	(fbDirector.Modo = E_GEMMA.A5PreparandoTrasFallo) OR 
	(fbDirector.Modo = E_GEMMA.D1ParadaEmergencia) OR 
	(fbDirector.Modo = E_GEMMA.D2TratamientoFallos);

ctInp.Reset := (* Restablece la condicion de fallo *)
    (fbDirector.Modo = E_GEMMA.A5PreparandoTrasFallo);

ctInp.Restart := (* Reinicia el estado del controlador *)
	(fbDirector.Modo = E_GEMMA.A6Inicializando);

ctInp.Restore := (* Restaura las condiciones iniciales (referencia) *)
    (fbDirector.Modo=E_GEMMA.A6Inicializando); 

ctInp.Resume := (* Continua la ejecucion de la funcionalidad en curso *)
	(FALSE);
	
ctInp.Safe := (* Condicion de seguridad para iniciar una funcionalidad *)
	(TRUE);

mdAlimentador.ctInp 			:= ctInp;
mdPickAndPlaceCarga.ctInp 		:= ctInp;
mdMedidorTapa.ctInp 			:= ctInp;
mdCaptadorInductivo.ctInp 		:= ctInp;
mdDetectorFotoelectrico.ctInp 	:= ctInp;
mdEvacuador.ctInp 				:= ctInp;
mdPickAndPlaceDescarga.ctInp 	:= ctInp;
mdPlatoDivisor.ctInp 			:= ctInp;

mdEvacuador.Evacuar := TRUE; // PENDIENTE DECISIÓN DE EVACUAR O NO EN FUNCIÓN DEL TIPO DE TAPA

fbFMS205_Producir_SFC(
	mdAlimentador 			:= mdAlimentador,
	mdPickAndPlaceCarga 	:= mdPickAndPlaceCarga,
	mdMedidorTapa			:= mdMedidorTapa,
	mdCaptadorInductivo 	:= mdCaptadorInductivo,
	mdDetectorFotoelectrico := mdDetectorFotoelectrico,
	mdEvacuador			 	:= mdEvacuador,
	mdPickAndPlaceDescarga 	:= mdPickAndPlaceDescarga,
	mdPlatoDivisor			:= mdPlatoDivisor);


(*	
mdAlimentador.ctInp.Execute := Execute;
mdAlimentador.ctInp.Ack := Ack;
mdAlimentador.ModuleProcessCycle();

mdCaptadorInductivo.ctInp.Execute := Execute AND mdAlimentador.ctOut.Done;
mdCaptadorInductivo.ctInp.Ack := Ack;
mdCaptadorInductivo.ModuleProcessCycle();
*)


(*
	
mdPickAndPlaceCarga.ctInp.Execute := Execute;

mdPickAndPlaceCarga.ModuleProcessCycle();
IF mdPickAndPlaceCarga.ctOut.Done THEN
	mdPickAndPlaceCarga.ctInp.Ack := TRUE;	
END_IF

mdMedidorTapa.ctInp.Execute := mdPickAndPlaceCarga.ctOut.Done;
mdMedidorTapa.ModuleProcessCycle();
IF mdMedidorTapa.ctOut.Done THEN
	mdMedidorTapa.ctInp.Ack := TRUE;	
END_IF

mdCaptadorInductivo.ModuleProcessCycle();
mdDetectorFotoelectrico.ModuleProcessCycle();
mdPickAndPlaceDescarga.ModuleProcessCycle(); 
mdCaptadorInductivo.ModuleProcessCycle(); 
*)]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>