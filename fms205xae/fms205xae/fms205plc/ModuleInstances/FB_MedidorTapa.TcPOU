<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.6">
  <POU Name="FB_MedidorTapa" Id="{a37cb369-72d3-405d-8544-ddf9b249bb92}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MedidorTapa EXTENDS FB_Module
(*

ESTACIÓN MEDICIÓN TAPA - Manual de usuario #32/28

El hecho de disponer de tapas con dos alturas diferentes hace necesario disponer de un elemento 
que realice una medición de las mismas. Debido a la finalidad didáctica con la cual se ha realizado el
diseño de esta célula, se han adoptado soluciones variadas para llevar a cabo operaciones similares. 
En otras estaciones, para operaciones de medición se ha recurrido a componentes como cilindros 
neumáticos con detectores de altura correcta, o palpadores con salida analógica. En este caso se ha 
considerado de interés utilizar un transductor digital que proporciona una salida por pulsos, como es el 
encoder lineal.

La imagen muestra el aspecto del componente utilizado, el cuál consta 
de un cilindro neumático que desplaza el palpador hasta contactar con la 
tapa, en combinación con un encoder lineal integrado en el mismo cilindro. 
Mediante la cuenta de los pulsos suministrados por el encoder, realizada 
mediante una entrada de contaje rápido del PLC, es posible determinar la 
distancia que avanza al cilindro hasta contactar con la tapa. Disponiendo de 
este dato es posible determinar de forma directa la altura de la tapa

*)

VAR_OUTPUT
	Lectura_Registrada	: BOOL;
	Altura_mm		: REAL;
	Altura_Pulsos	: UINT;
	strUi : STRING := '?';

END_VAR
VAR
	// Controlador
	fbController: FB_MedidorTapa_SFC:=(dr:=dr);

	// Sensores
	dh AT %I*: UINT; (*Detector valor altura *)

	// Actuadores
	L_1 : dvActuator := (dr:=dr); // AT %Q*: BOOL; (* Medidor de altura baja *)
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="InitialConditions" Id="{b1752ba1-1b26-4acb-b292-e17eb0af0fb4}">
      <Declaration><![CDATA[METHOD InitialConditions : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[InitialConditions:= TRUE; // TODO: ESTABLECER LOS VALORES DE FV QUE INDICAN QUE EL MEDIDOR ESTÁ EN POSICIÓN INICIAL]]></ST>
      </Implementation>
    </Method>
    <Method Name="ProcessCycle" Id="{d76d2d9a-68fd-4928-b9fd-2c031ae14f83}">
      <Declaration><![CDATA[METHOD ProcessCycle : BOOL 
VAR_INPUT
	dr	: REFERENCE TO FB_Director;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//----------------------------------- leer los sensores para determinar el estado del módulo

//----------------------------------- preparar los datos que necesita el controlador
IC := InitialConditions();

fbController.SFCPause := dr.gmModeActual = E_GEMMA.A3ParadaEstado;
fbController.SFCReset := dr.gmModeActual = E_GEMMA.A6Inicializando;

//----------------------------------- ejecutar el controlador
//fbModuleController(ctInp:=ctInp, ctOut=>ctOut);
fbController(
	// TMED := TMED,								// temporizadores específicos
    dh := dh,									// sensores específicos
	Lectura_Registrada	:= Lectura_Registrada,			// otras entradas específicas
	dr:=dr, IC:=IC, Execute:=Execute, Ack:=Ack, Ready=>Ready, Done=>Done);
	
L_1.ProcessCycle(dr:=dr, sfcValue:=fbController.L_1);
IsActive:=L_1.uiValue;

(*//----------------------------------- utilizar los resultados del controlador

// Cambios en actuadores por el modo manual
IF gm.ModeActual=E_GEMMA.F4VerificacionSinOrden THEN
	; // TODO AÑADIR AQUI EL MODO MANUAL DEL ALIMENTADOR

// Cambios en actuadores por el resultado del controlador
ELSE
	// Actualizar actuadores hardware con lo que indique el controlador
	L_1 := fbController.L_1;
END_IF
*)

// Leer la altura cuando el lector está abajo
IF fbController.Leyendo AND NOT Lectura_Registrada THEN
	Altura_Pulsos	:= dh;
	Altura_mm		:= -0.0257*dh + 52.532;				 // calcular la altura con la ecuación de regresión
	Altura_mm 		:= SEL(Altura_mm < 0, Altura_mm, 0); // si la altura es negativa dejar cero
	Lectura_Registrada 	:= TRUE;
	strUi := TO_STRING(Altura_mm);
	strUi := concat(strUi, ' mm');
ELSIF Ready THEN
	Lectura_Registrada 	:= FALSE; 	// Resetear la lectura para el siguiente ciclo
	Altura_Pulsos	:= 0;
	Altura_mm		:= 0;
	strUi := '?';
END_IF
	 



]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_MedidorTapa">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MedidorTapa.InitialConditions">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MedidorTapa.ProcessCycle">
      <LineId Id="3" Count="4" />
      <LineId Id="57" Count="0" />
      <LineId Id="9" Count="43" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>