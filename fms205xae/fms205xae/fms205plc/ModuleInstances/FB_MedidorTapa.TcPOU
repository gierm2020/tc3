<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_MedidorTapa" Id="{a37cb369-72d3-405d-8544-ddf9b249bb92}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MedidorTapa EXTENDS FB_Module
(*

ESTACIÓN MEDICIÓN TAPA - Manual de usuario #32/28

El hecho de disponer de tapas con dos alturas diferentes hace necesario disponer de un elemento 
que realice una medición de las mismas. Debido a la finalidad didáctica con la cual se ha realizado el
diseño de esta célula, se han adoptado soluciones variadas para llevar a cabo operaciones similares. 
En otras estaciones, para operaciones de medición se ha recurrido a componentes como cilindros 
neumáticos con detectores de altura correcta, o palpadores con salida analógica. En este caso se ha 
considerado de interés utilizar un transductor digital que proporciona una salida por pulsos, como es el 
encoder lineal.

La imagen muestra el aspecto del componente utilizado, el cuál consta 
de un cilindro neumático que desplaza el palpador hasta contactar con la 
tapa, en combinación con un encoder lineal integrado en el mismo cilindro. 
Mediante la cuenta de los pulsos suministrados por el encoder, realizada 
mediante una entrada de contaje rápido del PLC, es posible determinar la 
distancia que avanza al cilindro hasta contactar con la tapa. Disponiendo de 
este dato es posible determinar de forma directa la altura de la tapa

*)

VAR_OUTPUT
	LecturaFiable	: BOOL;
	Altura_mm		: REAL;
	Altura_Pulsos	: UINT;
END_VAR
VAR
	(* Controlador  específico *)
	fbController: FB_MedidorTapa_SFC;

	(* Temporizadores específicos *)
	TMED: TIME := T#1S;	
	
	(* Sensores específicos *)
	fv  AT %I*: UINT; (*Detector valor altura *)

	(* Actuadores específicos *)
	L_1 AT %Q*: BOOL; (* Medidor de altura baja *)	
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="InitialConditions" Id="{b1752ba1-1b26-4acb-b292-e17eb0af0fb4}">
      <Declaration><![CDATA[METHOD InitialConditions : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[InitialConditions:= TRUE; // TODO: ESTABLECER LOS VALORES DE FV QUE INDICAN QUE EL MEDIDOR ESTÁ EN POSICIÓN INICIAL]]></ST>
      </Implementation>
    </Method>
    <Method Name="ModuleControlFlow" Id="{d76d2d9a-68fd-4928-b9fd-2c031ae14f83}">
      <Declaration><![CDATA[METHOD ModuleControlFlow : BOOL 

]]></Declaration>
      <Implementation>
        <ST><![CDATA[//----------------------------------- leer los sensores para determinar el estado del módulo


//----------------------------------- preparar los datos que necesita el controlador
IC := InitialConditions();



//----------------------------------- ejecutar el controlador
//fbModuleController(ctInp:=ctInp, ctOut=>ctOut);
fbController(
	TMED := TMED,								// temporizadores específicos
    fv := fv,									// sensores específicos
	LecturaFiable	:= LecturaFiable,			// otras entradas específicas
	IC:=IC, Execute:=Execute, Ack:=Ack,
	Ready=>Ready, Done=>Done, Failure=>Failure);



//----------------------------------- utilizar los resultados del controlador

// Cambios en actuadores por el modo manual
IF gm.ModeActual=E_GEMMA.F4VerificacionSinOrden THEN
	; // TODO AÑADIR AQUI EL MODO MANUAL DEL ALIMENTADOR

// Cambios en actuadores por el resultado del controlador
ELSE
	// Actualizar actuadores hardware con lo que indique el controlador
	L_1 := fbController.L_1;
END_IF

// Leer la altura cuando el lector está abajo
IF fbController.Leyendo AND NOT LecturaFiable THEN
	Altura_Pulsos	:= fv;
	Altura_mm		:= -0.0257*fv + 52.532;				 // calcular la altura con la ecuación de regresión
	Altura_mm 		:= SEL(Altura_mm < 0, Altura_mm, 0); // si la altura es negativa dejar cero
	LecturaFiable 	:= TRUE;

ELSIF Ack THEN
	LecturaFiable 	:= FALSE; 	// Resetear la lectura para el siguiente ciclo
	Altura_Pulsos	:= 0;
	Altura_mm		:= 0;
END_IF
	 



]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>