<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="L6_Tapas" Id="{bb89ac45-4910-4319-9986-f6a3e6f8b97b}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK L6_Tapas
VAR CONSTANT
	ColSecIndeterm	: DWORD := 16#80101010; // gris claro
	ColSecVacio		: DWORD := 16#80808080; // gris oscuro
	ColSecPendiente : DWORD := 16#80000080; // azul
	ColSecDescargar	: DWORD := 16#80008000; // verde
	ColSecEvacuar	: DWORD := 16#80800000; // rojo
END_VAR

VAR_INPUT
	ReqNumero	: DINT := 2; 		// requisito de número de tapas deseadas
	ReqAlta		: REAL := 18.5;  	// requisito de tapa alta
	ReqVacio	: REAL := 2.0; 		// si mide menos el sector está vacío

	ReqAluBaja	: BOOL := FALSE;
	ReqAluAlta	: BOOL := TRUE;
	ReqBlnBaja  : BOOL := TRUE;
    ReqBlnAlta  : BOOL := FALSE;
	ReqNgrBaja  : BOOL := FALSE;
    ReqNgrAlta  : BOOL := FALSE; 

	ResPend	  	: DINT := 0;
	ResReal		: DINT := 0;
	ResRech   	: DINT := 0;
END_VAR

VAR_OUTPUT
	FaltaMat	: BOOL; 
	ExeAlime	: BOOL;	
	AckAlime	: BOOL;
	ExeCarga	: BOOL;
	AckCarga	: BOOL;
	ExeMedid	: BOOL;
	ExeFotoe	: BOOL;
	ExeInduc	: BOOL;
	ExeEvacu	: BOOL;
	AckEvacu	: BOOL;
	ExeDesca	: BOOL;
	AckDesca	: BOOL;
	ExeDescaAnt	: BOOL;
	ExePlato	: BOOL;
	AckPlato	: BOOL;
	ExeSitua	: BOOL;
	ExeTrans	: BOOL;
END_VAR

VAR
	//NumGiros 	: DINT := 0;
	PosCarga	: DINT;
	PosFotoe	: DINT;
	PosMedid	: DINT;
	PosInduc	: DINT;
	PosEvacu	: DINT;
	PosDesca	: DINT;
	Alimentada	: BOOL; // HAY UNA TAPA EN EL ALIMENTADOR ESPERANDO A SER CARGADA

	angulo	 	: REAL := 0.0;
	anguloanim 	: REAL := 0.0; // angulo para animación que gira lentamente
	//HaGirado	: BOOL := FALSE;
	//Falta_Material		: BOOL;

	vEvacuar_Tapa		: ARRAY[0..7] OF BOOL;
	vDescargar_Tapa		: ARRAY[0..7] OF BOOL;
	
	vInicializando 		: ARRAY[0..7] OF BOOL;	
	//vCargar_Tapa		: ARRAY[0..7] OF BOOL;
	vTapa_Cargada 		: ARRAY[0..7] OF BOOL;
	vAltura_Medida		: ARRAY[0..7] OF BOOL;
	vAltura_Pulsos 		: ARRAY[0..7] OF DWORD;
	vAltura_Mm 			: ARRAY[0..7] OF REAL;
	vTapa_Alta			: ARRAY[0..7] OF BOOL;
	vClaridad_Medida	: ARRAY[0..7] OF BOOL;
	vTapa_Clara 		: ARRAY[0..7] OF BOOL;	
	vMateral_Medido		: ARRAY[0..7] OF BOOL;	
	vTapa_Metalica 		: ARRAY[0..7] OF BOOL;	
	vstrUi 				: ARRAY[0..7] OF STRING;
	vstrToolTip			: ARRAY[0..7] OF STRING;
	vColorSector		: ARRAY[0..7] OF DWORD;
	
	vColorFill			: ARRAY[0..7] OF DWORD;
	vColorFont			: ARRAY[0..7] OF DWORD;	
	vColorFrame			: ARRAY[0..7] OF DWORD;

	Evacu_strUi			: STRING;
	Evacu_strToolTip	: STRING;	
	Evacu_ColorFont		: DWORD;
	Evacu_ColorFrame	: DWORD;
	Evacu_ColorFill		: DWORD;
	Evacu_PosX			: REAL;
	Evacu_PosY			: REAL;
	
	Desca_strUi			: STRING;
	Desca_strToolTip	: STRING;	
	Desca_ColorFont		: DWORD;
	Desca_ColorFrame	: DWORD;
	Desca_ColorFill		: DWORD;
	Desca_PosX			: REAL;
	Desca_PosY			: REAL;

	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="Actualizar" Id="{76d8c916-080e-414e-a1dc-0f3a274c86ba}">
      <Declaration><![CDATA[METHOD Actualizar : BOOL
VAR_INPUT
END_VAR

VAR
	i 	: INT := 0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR i:=0 TO 7 DO
	vstrTooltip[i] := CONCAT('Sector ', TO_STRING(i));
	vstrTooltip[i] := CONCAT(vstrTooltip[i], ' :');
	IF vInicializando[i] THEN
		vAltura_Medida[i]	:= FALSE;
		vAltura_Pulsos[i]	:= 0;
		vAltura_Mm[i] 		:= 0;
	
		vClaridad_Medida[i]	:= FALSE;
		vTapa_Clara[i] 		:= FALSE;
	
		vMateral_Medido[i]	:= FALSE;	
		vTapa_Metalica[i] 	:= FALSE;
	
		//vCargar_Tapa[i]		:= FALSE;
		vEvacuar_Tapa[i]	:= FALSE;
		vDescargar_Tapa[i]	:= FALSE;	
		vColorSector[i] 	:= ColSecIndeterm;
		vstrUi[i] 			:= '?';
		vstrTooltip[i] 		:= CONCAT(vstrTooltip[i], ' Contenido desconocido => Medir');
		
	ELSIF NOT vTapa_Cargada[i] THEN
		//vCargar_Tapa[i]		:= TRUE;
		vEvacuar_Tapa[i]	:= FALSE;
		vDescargar_Tapa[i]	:= FALSE;	
		vColorSector[i] 	:= ColSecVacio;
		vstrUi[i] 			:= '___';
		vstrTooltip[i] 	:= CONCAT(vstrTooltip[i], ' Sector vacío => Cargar');

	ELSE
		IF vAltura_Medida[i] THEN //  AND vTapa_Cargada[i] redundante porque se cumple
			vstrTooltip[i] 	:= CONCAT(vstrTooltip[i], SEL(vTapa_Alta[i], ' Baja (', ' Alta ('));
			vstrTooltip[i] 	:= CONCAT(vstrTooltip[i], TO_STRING(vAltura_Pulsos[i]));
			vstrTooltip[i] 	:= CONCAT(vstrTooltip[i], ' pulsos, ');
			vstrTooltip[i]	:= CONCAT(vstrTooltip[i], TO_STRING(vAltura_Mm[i]));
			vstrTooltip[i] 	:= CONCAT(vstrTooltip[i], ' mm);');
		ELSE
			vstrTooltip[i] 	:= CONCAT(vstrTooltip[i], ' ¿altura?;');
		END_IF
		
		IF vClaridad_Medida[i] THEN
			vstrTooltip[i] 	:= CONCAT(vstrTooltip[i], SEL(vTapa_Clara[i], ' oscura;', ' clara;'));
		ELSE
			vstrTooltip[i] 	:= CONCAT(vstrTooltip[i], ' ¿claridad?;');							
		END_IF
		IF vMateral_Medido[i] THEN
			vstrTooltip[i] 	:= CONCAT(vstrTooltip[i], SEL(vTapa_Metalica[i], ' plástico;', ' metal;'));
		ELSE
			vstrTooltip[i] 	:= CONCAT(vstrTooltip[i], ' ¿material?;');							
		END_IF
		
		IF vAltura_Medida[i] AND vClaridad_Medida[i] AND vMateral_Medido[i] THEN
			vDescargar_Tapa[i] := (
					(ReqAluAlta AND vTapa_Metalica[i] AND vTapa_Alta[i]) OR
					(ReqAluBaja AND vTapa_Metalica[i] AND NOT vTapa_Alta[i]) OR
					(ReqBlnAlta AND NOT vTapa_Metalica[i] AND vTapa_Clara[i]  AND vTapa_Alta[i]) OR
					(ReqBlnBaja AND NOT vTapa_Metalica[i] AND vTapa_Clara[i]  AND NOT vTapa_Alta[i]) OR
					(ReqNgrAlta AND NOT vTapa_Metalica[i] AND NOT vTapa_Clara[i]  AND vTapa_Alta[i]) OR
					(ReqNgrBaja AND NOT vTapa_Metalica[i] AND NOT vTapa_Clara[i]  AND NOT vTapa_Alta[i]));
			vEvacuar_Tapa[i] := NOT vDescargar_Tapa[i];
			vColorSector[i] := SEL(vDescargar_Tapa[i],ColSecEvacuar, ColSecDescargar);
			vstrTooltip[i] := CONCAT(vstrTooltip[i], SEL(vDescargar_Tapa[i], ' => Evacuar', '=> Descargar'));
		ELSE
			vDescargar_Tapa[i]	:= FALSE;
			vEvacuar_Tapa[i]	:= FALSE;
			vColorSector[i] 	:= ColSecPendiente; 			
			vstrTooltip[i] 		:= CONCAT(vstrTooltip[i], '=> Esperar');
		END_IF 
		vstrUi[i] := SEL(vAltura_Medida[i],'?', SEL(vTapa_Alta[i], 'B','A'));
		vstrUi[i] := CONCAT(vstrUi[i], SEL(vClaridad_Medida[i], '?',SEL(vTapa_Clara[i],'O','C')));
		vstrUi[i] := CONCAT(vstrUi[i], SEL(vMateral_Medido[i], '?', SEL(vTapa_Metalica[i], 'P','M'))); 		
	END_IF
	
	IF vInicializando[i] THEN								// caso A ?
		vColorFill[i]		:= colDesFill;
		vColorFont[i]		:= colDesFont;
		vColorFrame[i]		:= colDesFrameSin;
	ELSIF NOT vTapa_Cargada[i] THEN							// Caso B ___
		vColorFill[i]		:= colVacFill;
		vColorFont[i]		:= colVacFont;
		vColorFrame[i]		:= colVacFrameSin;
	ELSIF NOT vClaridad_Medida[i] THEN						// Caso C A??
		vColorFill[i]		:= colTapFill;
		vColorFont[i]		:= colTapFont;
		vColorFrame[i]		:= colTapFrameSin;
	ELSIF vTapa_Clara[i] AND NOT vMateral_Medido[i] THEN	// Caso D AC?
		vColorFill[i]		:= colClaFill;
		vColorFont[i]		:= colClaFont;
		vColorFrame[i]		:= colClaFrameSin;
	ELSIF NOT vTapa_Clara[i] AND NOT vMateral_Medido[i] THEN // Caso E AO?
		vColorFill[i]		:= colClaFill;
		vColorFont[i]		:= colClaFont;
		vColorFrame[i]		:= colClaFrameSin;
	ELSIF vTapa_Clara[i] AND vTapa_Metalica[i] THEN 		// Caso F ACM
		vColorFill[i]		:= colAluFill;
		vColorFont[i]		:= colAluFont;
		vColorFrame[i]		:= colAluFrameSin;
	ELSIF vTapa_Clara[i] AND NOT vTapa_Metalica[i] THEN 	// Caso G ACP
		vColorFill[i]		:= colBlnFill;
		vColorFont[i]		:= colBlnFont;
		vColorFrame[i]		:= colBlnFrameSin;
	ELSIF NOT vTapa_Clara[i] AND NOT vTapa_Metalica[i] THEN // Caso G AOP
		vColorFill[i]		:= colNgrFill;
		vColorFont[i]		:= colNgrFont;
		vColorFrame[i]		:= colNgrFrameSin;
	ELSE
		vColorFill[i]		:= colErrFill;
		vColorFont[i]		:= colErrFont;
		vColorFrame[i]		:= colErrFrameSin;		
	END_IF
	IF vDescargar_Tapa[i] THEN
		vColorFrame[i]		:= colAluFrameOk; // se aplica el mismo independientemente del tipo de tapa!	
	END_IF
	IF vEvacuar_Tapa[i] THEN
		vColorFrame[i]		:= colAluFrameKo; // se aplica el mismo independientemente del tipo de tapa!			
	END_IF
END_FOR 
ResPend := ReqNumero - ResReal;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="DebeMedir" Id="{91bd8973-cc91-4eee-8520-1f698b098d00}">
      <Declaration><![CDATA[METHOD DebeMedir : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[DebeMedir := not vAltura_Medida[PosMedid];]]></ST>
      </Implementation>
    </Method>
    <Method Name="Inicializar" Id="{4758c6c6-4ea4-433c-a79f-8e413ab5f879}">
      <Declaration><![CDATA[METHOD Inicializar : BOOL

VAR_INPUT
	DebePreparar 	: BOOL := TRUE;
END_VAR

VAR
	i : DINT;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[ReqAluBaja		:= TRUE;
ReqAluAlta		:= TRUE;
ReqBlnBaja  	:= TRUE;
ReqBlnAlta  	:= TRUE;
ReqNgrBaja  	:= TRUE;
ReqNgrAlta  	:= TRUE; 
Alimentada 		:= FALSE;

ResPend	  		:= 0;
ResReal			:= 0;
ResRech   		:= 0;

//NumGiros	 	:= 0;
FaltaMat		:= FALSE;
PosMedid 		:= 6; // (NumGiros+6) MOD 8;
PosFotoe 		:= 5; // (NumGiros+5) MOD 8;
PosInduc 		:= 4; // (NumGiros+4) MOD 8;
PosEvacu 		:= 2; // (NumGiros+2) MOD 8;
PosDesca		:= 1; // (NumGiros+1) MOD 8;
PosCarga		:= 0; //(NumGiros+0) MOD 8;

angulo	 		:= 0.0;
anguloanim 		:= 0.0; // angulo para animación que gira lentamente
//HaGirado		:= FALSE;
ExePlato		:= FALSE;


FOR i:=0 TO 7 DO
	//IF DebePreparar THEN
		vInicializando[i] 	:= TRUE;
	//ELSE
	//	Vaciar(i);
	//END_IF
END_FOR
Actualizar();]]></ST>
      </Implementation>
    </Method>
    <Method Name="PostCarga" Id="{276efb06-172e-4a1d-961d-2890acac9513}">
      <Declaration><![CDATA[METHOD PostCarga : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[vInicializando[PosCarga]	:= FALSE;		
vTapa_Cargada[PosCarga]		:= TRUE;
vAltura_Medida[PosCarga]	:= FALSE;
vAltura_Pulsos[PosCarga]	:= 0;
vAltura_Mm[PosCarga] 		:= 0;		
vClaridad_Medida[PosCarga]	:= FALSE;
vTapa_Clara[PosCarga] 		:= FALSE;		
vMateral_Medido[PosCarga]	:= FALSE;	
vTapa_Metalica[PosCarga] 	:= FALSE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="PostDesca" Id="{35a2ad5e-41b0-4f8a-8514-f3f5cb606af3}">
      <Declaration><![CDATA[METHOD PostDesca : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ResReal 			:= ResReal + 1;
ResPend				:= ReqNumero - ResReal;
Desca_strUi			:= vstrUi[PosDesca];
Desca_strToolTip	:= vstrToolTip[PosDesca];
Desca_ColorFont		:= vColorFont[PosDesca];
Desca_ColorFrame	:= vColorFrame[PosDesca];
Desca_ColorFill		:= vColorFill[PosDesca];
Vaciar(PosVacia	:= PosDesca);	

]]></ST>
      </Implementation>
    </Method>
    <Method Name="PostEvacu" Id="{5caa088b-866e-4274-a9c7-1d9f312ea165}">
      <Declaration><![CDATA[METHOD PostEvacu : BOOL

VAR_INPUT
	Ready	: BOOL;
	Done	: BOOL;
	Evacuar	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ResRech 			:= ResRech + 1;
Evacu_strUi			:= vstrUi[PosEvacu];
Evacu_strToolTip	:= vstrToolTip[PosEvacu];
Evacu_ColorFont		:= vColorFont[PosEvacu];
Evacu_ColorFrame	:= vColorFrame[PosEvacu];
Evacu_ColorFill		:= vColorFill[PosEvacu];
Vaciar(PosVacia	:= PosEvacu);	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="PostFotoe" Id="{afe73e40-fb85-4efe-b906-85a197d79803}">
      <Declaration><![CDATA[METHOD PostFotoe : BOOL
VAR_INPUT
	Tapa_Clara: BOOL;
END_VAR

VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//ExeFotoe 					:= FALSE;
vClaridad_Medida[PosFotoe]	:= TRUE;
vTapa_Clara[PosFotoe]		:= Tapa_Clara;
//Actualizar();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="PostInduc" Id="{88973f08-454f-49dc-aa0f-ae73f3546455}">
      <Declaration><![CDATA[METHOD PostInduc : BOOL
VAR_INPUT
	Tapa_Metalica: BOOL;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[//ExeInduc					:= FALSE;
vMateral_Medido[PosInduc]	:= TRUE;
vTapa_Metalica[PosInduc]	:= Tapa_Metalica;
//Actualizar();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="PostMedid" Id="{e0bd59f6-28b6-48d4-9b89-31b0758ec910}">
      <Declaration><![CDATA[METHOD PostMedid : BOOL
VAR_INPUT
	Altura_Mm			: REAL;
	Altura_Pulsos		: UDINT;	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//ExeMedid 						:= FALSE;
vInicializando[PosMedid]		:= FALSE;	
IF Altura_Mm < ReqVacio THEN
	Vaciar(PosVacia:=PosMedid);
ELSE
	vTapa_Cargada[PosMedid]		:= TRUE;			
	vAltura_Medida[PosMedid]	:= TRUE;
	vAltura_Pulsos[PosMedid]	:= Altura_Pulsos;
	vAltura_Mm[PosMedid]		:= Altura_mm;
	vTapa_Alta[PosMedid]		:= Altura_mm > ReqAlta;
	//Actualizar();
END_IF	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ProcessCycle" Id="{44f6408c-3ad5-45e0-8b3e-a46b21623d3f}">
      <Declaration><![CDATA[METHOD ProcessCycle : BOOL
VAR_INPUT
	dr				: REFERENCE TO L1_Director;
	pn				: REFERENCE TO L5_Panel;
	NumGiros 		: DINT;
	//TapaDisponible	: BOOL;
	TapaCargada		: BOOL; // El brazo de carga ha movido la tapa cargada al plato
	TapaEvacuada	: BOOL;
	TapaDescargada	: BOOL;
	
	// Falta_Material	: BOOL;
	//Hay_Pale		: BOOL;
	ctrlF1			: REFERENCE TO L4_FMS205_F1Producir_SFC;
	ctrlF2			: REFERENCE TO L4_FMS205_F2SeqPrep_SFC;
	ctrlF3			: REFERENCE TO L4_FMS205_F3SeqFin_SFC;
	ctrlF6			: REFERENCE TO L4_FMS205_F6Prueba_SFC;
	//Ready			: BOOL;
	//Done			: BOOL;
	
END_VAR


VAR
	F1	: BOOL;
	A2	: BOOL;
	F2	: BOOL;
	F3	: BOOL;
	F4	: BOOL;
	F5	: BOOL;
	F6	: BOOL;
	i	: int;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF dr.gmModeActual = L1_GEMMA.A6Inicializando THEN
	ReqAluBaja		:= TRUE;
	ReqAluAlta		:= TRUE;
	ReqBlnBaja  	:= TRUE;
	ReqBlnAlta  	:= TRUE;
	ReqNgrBaja  	:= TRUE;
	ReqNgrAlta  	:= TRUE; 

	ResPend	  		:= 0;
	ResReal			:= 0;
	ResRech   		:= 0;

	//NumGiros	 	:= 0;
	//FaltaMat		:= FALSE;

	//angulo	 		:= 0.0;
	//anguloanim 		:= 0.0; // angulo para animación que gira lentamente

	FOR i:=0 TO 7 DO
		IF dr.cnF3_Finalizar THEN 
			vInicializando[i] 	:= TRUE;
		ELSE
			Vaciar(PosVacia := i);
		END_IF
	END_FOR	
	ExeDescaAnt 	:= FALSE; // guarda si se descargó en el paso anterior
END_IF

PosMedid 			:= (NumGiros+6) MOD 8;					// -------------- Actualizar posiciones
PosFotoe 			:= (NumGiros+5) MOD 8;
PosInduc 			:= (NumGiros+4) MOD 8;
PosEvacu 			:= (NumGiros+2) MOD 8;
PosDesca			:= (NumGiros+1) MOD 8;
PosCarga			:= (NumGiros+0) MOD 8;

F1					:= ctrlf1.Ready AND dr.gmModeActual=L1_GEMMA.F1ProduccionNormal AND NOT dr.EndBatch;
A2					:= ctrlf1.Ready AND dr.gmModeActual=L1_GEMMA.A2ParaFinCiclo AND NOT dr.EndBatch;
F2					:= ctrlF2.Ready AND dr.gmModeActual=L1_GEMMA.F2SecuenciaPreparacion;
F3					:= ctrlF3.Ready AND dr.gmModeActual=L1_GEMMA.F3SecuenciaFinalizacion;
F6					:= ctrlF6.Ready AND dr.gmModeActual=L1_GEMMA.F6Probando;
F5					:= pn.swF5_Ejecutar AND dr.gmModeActual=L1_GEMMA.F5VerificacionOrdenada;


//IF TapaEvacuada THEN
	//ResRech 		:= ResRech + 1;
	//Vaciar(PosVacia := PosEvacu);	
//END_IF


Actualizar();		// calcula qué posiciones hay que descargar o evacuar

IF F1 OR A2 OR F2 OR F3 OR F6 OR F5 THEN
	//ExeSitua			:= (F1 OR A2 OR F6 OR (F5 AND pn.swF5_Situar)) AND NOT Hay_Pale;
	//ExeAlime			:= (F1 OR A2 OR F6 OR (F5 AND pn.swF5_Alimentar) AND NOT TapaAlimentada);  // Alimentada);
	//ExeCarga			:= (F1 OR A2 OR F6 OR (F5 AND pn.swF5_Cargar)) AND TapaAlimentada AND  //NOT Falta_Material AND Alimentada AND
	//						NOT vInicializando[PosCarga] AND NOT vTapa_Cargada[PosCarga];
	ExeMedid			:= (F1 OR A2 OR F6 OR (F5 AND pn.swF5_Medir) OR F2);
	ExeFotoe			:= (F1 OR A2 OR F6 OR (F5 AND pn.swF5_Claridad) OR F2);
	ExeInduc			:= (F1 OR A2 OR F6 OR (F5 AND pn.swF5_Material) OR F2);
	ExeEvacu			:= ((F1 OR A2 OR F6 OR (F5 AND pn.swF5_Evacuar)) AND vEvacuar_Tapa[PosEvacu]) OR
						   (F3 AND vTapa_Cargada[PosEvacu]);
	ExeDesca			:= (F1 OR A2 OR F6 OR (F5 AND pn.swF5_Descargar)) AND vDescargar_Tapa[PosDesca];
	ExePlato			:= (F1 OR A2 OR F6 OR (F5 AND pn.swF5_Girar) OR F2 OR F3);
	ExeTrans			:= ExeDescaAnt OR (F5 AND pn.swF5_Transferir); // se transfiere si se descargó en la etapa anterior
	
	IF ctrlf1.Ready AND ctrlF6.Ready THEN // guarda la decisión de descarga para la transferencia del siguiente ciclo
		ExeDescaAnt		:= ExeDesca; 	
	END_IF
ELSE
	ExeSitua			:= FALSE;
	ExeAlime			:= FALSE;
	ExeCarga			:= FALSE;
	ExeMedid			:= FALSE;
	ExeFotoe			:= FALSE;
	ExeInduc			:= FALSE;
	ExeEvacu			:= FALSE;
	ExeDesca			:= FALSE;
	ExePlato			:= FALSE;
	ExeTrans			:= FALSE;
END_IF

//angulo 					:= -45.0 * (NumGiros MOD 8); //  SEL(angulo=0, angulo-45.0, 315.0); // , angulo+45.0, 0);
	
//IF ExePlato AND anguloanim >-35.0 THEN
	//anguloanim 	:= anguloanim - 0.2;	
//END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="PuedeCargar" Id="{ba066ebf-3b60-4cfe-b26b-d2ac0a5a26a5}">
      <Declaration><![CDATA[METHOD PuedeCargar : BOOL // TRUE SI EL SECTOR DE CARGA ESTÁ VACÍO
]]></Declaration>
      <Implementation>
        <ST><![CDATA[PuedeCargar := NOT vInicializando[PosCarga] AND not vTapa_Cargada[PosCarga];	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="PuedeDescargar" Id="{6ff31fda-6284-47de-bde5-d1ff905a8ea2}">
      <Declaration><![CDATA[METHOD PuedeDescargar : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[PuedeDescargar := vDescargar_Tapa[PosDesca];]]></ST>
      </Implementation>
    </Method>
    <Method Name="PuedeEvacuar" Id="{47537ed4-bf8a-43ed-8692-953ee9cb9e1f}">
      <Declaration><![CDATA[METHOD PuedeEvacuar : BOOL // TRUE SI EL SECTOR CONTIENE UNA TAPA INVÁLIDAD EN LA POSICIÓN DE EVACUACIÓN
VAR_INPUT
	gmMode		: L1_GEMMA;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[PuedeEvacuar := vEvacuar_Tapa[PosEvacu]  OR (gmMode=L1_GEMMA.F3SecuenciaFinalizacion AND vTapa_Cargada[PosEvacu]);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Vaciar" Id="{3cc88831-9ad2-4cbf-830e-7f9be896f2fe}">
      <Declaration><![CDATA[METHOD Vaciar : BOOL
VAR_INPUT
	PosVacia: DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[vInicializando[PosVacia]	:= FALSE;	
vTapa_Cargada[PosVacia]		:= FALSE;	
vAltura_Medida[PosVacia]	:= FALSE;
vAltura_Pulsos[PosVacia]	:= 0;
vAltura_Mm [PosVacia]		:= 0;	
vClaridad_Medida[PosVacia]	:= FALSE;
vTapa_Clara[PosVacia] 		:= FALSE;
vMateral_Medido[PosVacia]	:= FALSE;	
vTapa_Metalica[PosVacia] 	:= FALSE;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>