<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="L1_Director" Id="{1485be2f-2009-4092-b7e4-7ed9a9ca4fab}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK L1_Director
(*

Módulo L1_Director

Entrada: consignas generadas a partir del panel físico, la interfaz de usuario y el estado de la estación
Salida: nuevo estado de Gemma

1. Consignas

	cnA2_FinCiclo:			Solicitud de que la estación se detenga cuando acabe el ciclo
	cnA3_Estado:			Solicitud de que la estación se detenga lo antes posible
	cnA6_Inicializar: 		Solicitud de inicialización de la estación
	
	cnF0_Empezar: 			Solicitud de empezar a Producir/Pobar o continuar después de una parada/fallo
	cnF1_Producir:			Solicitud de producción, incluyendo secuencias de preparación=F2/finalización=F3
	cnF2_Preparar:			Solicitud de que la estación ejecute la secuencia de praparación antes de empezar el lote
	cnF3_Finalizar:			Solicitud de que se ejecute la secuencia de finalización después de acabar el lote
	cnF4_Planta:			Solicitud de paso al modo manual
	cnF5_Funcion:			Solicitud de prueba de grafcets a nivel de módulo
	cnF6_Probar				Solicitud de prueba secuencial de la estación (monolítico)

	cnD1_Emergencia: 		Solicitud de parada de emergencia


2. Estado de la estación

	IC:						La estación cumple las condiciones iniciales
	Failure:				Alguno de los módulos de la estación ha fallado
	EndCycle:				La estación ha terminado un ciclo de producción
	EndBatch:				La estación ha terminado de producir el lote
	IsPaused:				Todos los módulos de la estación se han detenido

3. Modos GEMMA
	A1ParadaInicial:		La estación está parada esperando instrucciones
	A2ParaFinCiclo:			Estación produciendo pero se detendrá cuando se termine el ciclo actual
	A3ParadaEstado:			Estación en marcha pero se detendrá en cuanto alcance un estado estable (IsSafe)
	A4ParadaObtenida: 		La estación está detenida después de alcanzar un estado estable
	A5PreparandoTrasFallo:	La estación está cambiando al modo anterior a que se produjera el fallo
	A6Inicializadndo:		Estación inicializando esperando a que se cumplan las condiciones iniciales
	A7SituandoEstado:		Modo no tratado 
	
	F1ProduccionNormal:		Estación produciendo el lote piezas
	F2SecuenciaPreparacion:	Estación preparándose para producir (evaluando qué hay en cada sector del plato)
	F3SecuenciaFinalizacion:Estación finalizando la producción (vaciando las tapas que quedan en el plato)	
	F4VerificacionSinOrden:	Estación en modo manual
	F5VerificacionOrdenada: Estación ejecutando un Grafcet a nivel de módulo
	F6Probando:				Estación ejecutando el Grafcet secuencial (monolítico)

	D1ParadaEmergencia: 	Estación ha entrado en parada de emergencia
	D2TratamientoFallos:	Estación detenida (o en modo F4) para corregir el fallo que se ha producido
	D3ProducirConFallos:	Estado no tratado

	
*)

VAR CONSTANT
	gmColorArret 	: DWORD := 16#FF808080;
	gmColorFonct 	: DWORD := 16#FF000080;
	gmColorDefail 	: DWORD := 16#FF800000;
END_VAR

VAR_INPUT
	IC 				: BOOL := TRUE; 			// todos los módulos están en condiciones iniciales
	IsPaused		: BOOL := TRUE; 			// estación en estado estable con todos los módulos detenidos
	EndCycle		: BOOL := FALSE;			// se ha completado un ciclo con/sin rechazo/descarga
	EndBatch		: BOOL := FALSE; 			// se han completado todas las tapas del lote
	Failure			: BOOL := FALSE;			// hay al menos un módulo que ha fallado

	cnA1_ParadaIni	: BOOL;
	cnF0_Empezar	: BOOL;
	
	
	cnF1_Producir	: BOOL;
	cnF2_Preparar	: BOOL;
	//IsPrepared		: BOOL := TRUE; 			// secuencia de preparación completada
	
	cnA2_FinCiclo	: BOOL;
	cnA3_Estado		: BOOL;
	cnF3_Finalizar	: BOOL;
	//IsFinished		: BOOL := TRUE; 			// secuencia de finalización completada
	
	cnF5_Funcion	: BOOL; 					// modo verificación ordenada
	cnF6_Probar		: BOOL;

	cnF4_Planta		: BOOL; 					// modo verificación sin orden	
	cnD1_Emergencia	: BOOL; 					// pulsar la seta
	cnA6_Inicializar: BOOL;
	//cnF1_Reanudar	: BOOL;

END_VAR

VAR_OUTPUT
	gmLocalHost		: BOOL 		:= FALSE; 		// TODO - SUSTITUIR ESTO POR LA CONDICIÓN DE LOCALHOST		
	gmModeActual	: L1_GEMMA 	:= L1_GEMMA.A6Inicializando; 		// Modo GEMMA actual
	gmModePrev		: L1_GEMMA; 				// Modo GEMMA anterior al actual
	gmModeColor		: DWORD 	:= gmColorArret;
	Tic				: BOOL		:= FALSE; 		// Se activa y desactiva cada 500 ms
	Clock			: TON;						// Temporizador para activar/desactivar Tic
END_VAR	

VAR
	gmFamiArret		: BOOL 		:= TRUE; 		// Familia de parada
	gmFamiFonct		: BOOL 		:= FALSE; 		// Familia de funcionamiento
	gmFamiDefail	: BOOL 		:= FALSE; 		// Familia de salida de fallos
	
	Speed			: REAL := 100.0;			// Velocidad variable de los controladores
	LastSpeed		: real := 0;			// para calcular sólo si hay cambio de velocidad
	
	
	//---------------------------------- dt_ Defalut Times	
	dt_MaximoTiempoRespuesta	: TIME := T#5S;				// Tiempos generales
	dt_TiempoReinicio			: TIME := T#5S;	
	dt_K_1 						: TIME := T#1S;				// Temporizador empujador tapa
	dt_R_1						: TIME := T#0.5S;			// Temporizador retenedor de la cinta
	dt_S_1						: TIME := T#0.5S;			// Temporizador separador de la cinta
	dt_EP						: TIME := T#0.5S;			// Tiempo de entrada del pale
	dt_TP						: TIME := T#1S;				// Tiempo de transferencia del pale
	dt_XP						: TIME := T#1S;				// Tiempo de salida del pale
	dt_SOL 						: TIME := T#100MS; 			// tiempo después de soltar y antes de subir
	dt_V_1						: TIME := T#5S;				// tiempo máximo succionando sin que se active el sensor v1
	dt_L_1						: TIME := T#1S;				// tiempo máximo de bajada del medidor de tapas
	dt_PIN 						: TIME := T#1S;				// tiempo para pinzar una tapa antes de subir el brazo
	dt_E_1						: TIME := T#400MS;			// tiempo para que el retenedor bloquee el plato
	dt_D_1 						: TIME := T#1.4S;			// tiempo para girar el plato a la siguiente posición
END_VAR


VAR_OUTPUT
	tmMaximoTiempoRespuesta		: TIME := dt_MaximoTiempoRespuesta;
	tmTiempoReinicio			: TIME := dt_TiempoReinicio;	
	tmK_1 						: TIME := dt_K_1;			// Temporizador empujador tapa
	tmR_1						: TIME := dt_R_1;			// Temporizador retenedor de la cinta
	tmS_1						: TIME := dt_S_1;			// Temporizador separador de la cinta
	tmEP						: TIME := dt_EP;			// Tiempo de entrada del pale
	tmTP						: TIME := dt_TP;			// Tiempo de transferencia del pale
	tmXP						: TIME := dt_XP;			// Tiempo de salida del pale
	tmSOL 						: TIME := dt_SOL; 			// tiempo después de soltar y antes de subir
	tmV_1						: TIME := dt_V_1;			// tiempo máximo succionando sin que se active el sensor v1
	tmL_1						: TIME := dt_L_1;		// tiempo máximo de bajada del medidor de tapas
	tmPIN 						: TIME := dt_PIN;		// tiempo para pinzar una tapa antes de subir el brazo
	tmE_1						: TIME := dt_E_1;		// tiempo para que el retenedor bloquee el plato
	tmD_1 						: TIME := dt_D_1;		// tiempo para girar el plato a la siguiente posición
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="ProcessCycle" Id="{9978d0af-5f0b-4b42-9ddf-3fb2a96798f7}">
      <Declaration><![CDATA[METHOD ProcessCycle : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Actualiza el reloj y la veloidad cada medio segundo
Clock(IN := NOT Clock.Q, PT:=T#500MS);
IF Clock.Q THEN
	Tic := NOT Tic;
	UpdateSpeed();
END_IF


IF cnD1_Emergencia AND NOT cnF4_Planta THEN
    gmModeActual 		:= L1_GEMMA.D1ParadaEmergencia;
//	gmModePrev 			:= L1_GEMMA.D1ParadaEmergencia;
//	IF cnF4_Planta THEN 				
//		gmModePrev := L1_GEMMA.D1ParadaEmergencia
//		gmModeActual := L1_GEMMA.F4VerificacionSinOrden;
//	ELSE
//		; // desde emergencia se puede pasar a F4 (desarmando la seta)				
//	END_IF
//		
	
ELSIF cnA6_Inicializar and not cnF4_Planta THEN 
    gmModeActual 		:= L1_GEMMA.A6Inicializando;
	// gmModePrev 			:= L1_GEMMA.L1_GEMMA.A6Inicializando;	

END_IF
	
    CASE gmModeActual OF
		
	
        (* ------------------------------------------------------------ Procedimientos de parada *)
		
        L1_GEMMA.A6Inicializando: (* A6 -> A1 o F4 *)
			gmModePrev := L1_GEMMA.A6Inicializando;
            IF IC THEN 
                gmModeActual := L1_GEMMA.A1ParadaInicial;
			ELSIF cnF4_Planta THEN 				
                gmModeActual := L1_GEMMA.F4VerificacionSinOrden;
            END_IF

			
			
			
        L1_GEMMA.A1ParadaInicial: (* A1 -> A6, F4, F5, F2 o F6 *)
			gmModePrev := L1_GEMMA.A1ParadaInicial;
            IF NOT IC THEN // IF NOT Restaurada THEN
                gmModeActual := L1_GEMMA.A6Inicializando;				
            ELSIF cnF4_Planta THEN 				
                gmModeActual := L1_GEMMA.F4VerificacionSinOrden;				
			ELSIF cnF5_Funcion THEN 
				gmModeActual := L1_GEMMA.F5VerificacionOrdenada;             
			ELSIF cnF1_Producir AND cnF0_Empezar THEN
                gmModeActual := L1_GEMMA.F2SecuenciaPreparacion;
			ELSIF cnF6_Probar AND cnF0_Empezar THEN
				gmModeActual := L1_GEMMA.F6Probando;
			ELSE
				; // Esperar a que se pulse el bortón de marcha
            END_IF

			
			
        L1_GEMMA.F4VerificacionSinOrden: (* F4 -> ModePrev *)
            //IF Failure THEN
			//	gmModeActual := L1_GEMMA.D2TratamientoFallos;				
            //ELSIF NOT cnF4_Planta THEN
			IF NOT cnF4_Planta THEN 				
				gmModeActual := gmModePrev; // al salir del modo planta volver al modo previo				
            ELSE                
                ; // Seguir en modo manual
            END_IF

			
			
		L1_GEMMA.F1ProduccionNormal, 		
        L1_GEMMA.A2ParaFinCiclo,
        L1_GEMMA.F2SecuenciaPreparacion, 	
		L1_GEMMA.F3SecuenciaFinalizacion, 	
        L1_GEMMA.F5VerificacionOrdenada,  	
		L1_GEMMA.F6Probando: 				        
			// retorno desde tratamiento de errores y planta
			IF gmModeActual=L1_GEMMA.F5VerificacionOrdenada THEN
				gmModePrev := L1_GEMMA.A1ParadaInicial; 								// F5 retorna a A1
			ELSE
				gmModePrev := gmModeActual;												// Resto retorna donde quedó			
			END_IF			
			
			// cambios de modo actual
            IF Failure THEN 															// cualquiera -> D2
                gmModeActual := L1_GEMMA.D2TratamientoFallos;
            ELSIF cnA3_Estado THEN				
				gmModeActual := L1_GEMMA.A3ParadaEstado; 								// cualquiera -> A3
			ELSIF cnF4_Planta THEN 				
                gmModeActual := L1_GEMMA.F4VerificacionSinOrden;						// cualquiera -> F4
            ELSIF gmModeActual=L1_GEMMA.F2SecuenciaPreparacion AND NOT cnF2_Preparar THEN 	// F2-> F1
                gmModeActual:= L1_GEMMA.F1ProduccionNormal;
			ELSIF gmModeActual=L1_GEMMA.F1ProduccionNormal AND cnA2_FinCiclo THEN 		// F1 -> A2				
				gmModeActual:= L1_GEMMA.A2ParaFinCiclo;
			ELSIF gmModeActual=L1_GEMMA.A2ParaFinCiclo AND EndCycle THEN 				// A2 -> A3
				gmModePrev  := L1_GEMMA.F1ProduccionNormal; 							// A2 -> A3 ... -> F1
                gmModeActual:= L1_GEMMA.A3ParadaEstado;
			ELSIF gmModeActual=L1_GEMMA.F1ProduccionNormal AND EndBatch THEN 			// F1-> F3
                gmModeActual:= L1_GEMMA.F3SecuenciaFinalizacion;
			ELSIF gmModeActual=L1_GEMMA.F3SecuenciaFinalizacion AND NOT cnF3_Finalizar THEN // F3 -> A1
				gmModeActual:= L1_GEMMA.A1ParadaInicial;
			ELSIF gmModeActual=L1_GEMMA.F5VerificacionOrdenada AND NOT cnF5_Funcion THEN // F5 -> A1
				gmModeActual:= L1_GEMMA.A1ParadaInicial;				
			ELSIF gmModeActual=L1_GEMMA.F6Probando AND NOT cnF6_Probar THEN 			// F6 -> A1
				gmModeActual:= L1_GEMMA.A1ParadaInicial; 
            ELSE                
                ; // continuar con la preparación/producción/finalización
            END_IF
			

			
        L1_GEMMA.A3ParadaEstado: 
            IF Failure THEN																// A3 -> D2
                gmModeActual := L1_GEMMA.D2TratamientoFallos;
			ELSIF IsPaused THEN															// A3 -> A4
                gmModeActual := L1_GEMMA.A4ParadaObtenida;
            ELSE
                ; // Seguir produciendo hasta que todos los módulos paren en un estado estable
            END_IF
            			
        L1_GEMMA.A4ParadaObtenida:
			IF cnF0_Empezar THEN														// A4 -> retorna
				gmModeActual := gmModePrev; // retomar el estado antes de la parada
			ELSE
				; // seguir parada hasta la consigna de reanudar	
			END_IF
                    
		L1_GEMMA.A5PreparandoTrasFallo:
			gmModeActual := gmModePrev;		// Volver al estado anterior al fallo 
			
        L1_GEMMA.A7SituandoEstado: (* Situando la PO en un estado determinado *)
            ; // estado no tratado en la FMS205

			
			
        (* ------------------------------------------------------------ Procedimientos de funcionamiento *)
        
			
			
			
			
        	
			
        (* ------------------------------------------------------------ Procedimientos de defecto *)
        L1_GEMMA.D1ParadaEmergencia: (* Parada de emergencia *)
			IF NOT cnD1_Emergencia THEN //  TODO CONSIGNA DE EMERGENCIA DEBE TENER ENCUENTA LA POC
                gmModeActual := L1_GEMMA.A6Inicializando; // Al quitar la parada de emergencia hay que reinicializar la estación
			ELSIF cnF4_Planta then							// desde A1 se puede entrar F4 para arreglar el problema
				gmModePrev := L1_GEMMA.D1ParadaEmergencia;
				gmModeActual := L1_GEMMA.F4VerificacionSinOrden;
            ELSE                
                ; // Esperar a que se quite la parada de emergencia
            END_IF
			
        L1_GEMMA.D2TratamientoFallos: (* Diagnostico/tratamiento de los fallos *)
            IF NOT Failure THEN // el fallo se resuelve por sí solo (no debería pasar)
                gmModeActual := L1_GEMMA.A5PreparandoTrasFallo;
			ELSIF cnF4_Planta THEN // se pasa a modo F4 para arreglarlo
				gmModeActual := L1_GEMMA.F4VerificacionSinOrden;
            ELSIF cnF0_Empezar THEN // se pulsa Marcha para intentar recuperar                
                gmModeActual := L1_GEMMA.A5PreparandoTrasFallo;
            END_IF

        L1_GEMMA.D3ProducirConFallos: (* Produccion a pesar de los fallos *)
            ; // estado no tratado en la FMS205

    END_CASE
// END_IF

(* PARAMETROS DE SALIDA *)
gmFamiArret  := (gmModeActual >= L1_GEMMA.A1ParadaInicial) AND (gmModeActual <= L1_GEMMA.A7SituandoEstado);
gmFamiFonct  := (gmModeActual >= L1_GEMMA.F1ProduccionNormal) AND (gmModeActual <= L1_GEMMA.F6Probando);
gmFamiDefail := (gmModeActual >= L1_GEMMA.D1ParadaEmergencia) AND (gmModeActual <= L1_GEMMA.D3ProducirConFallos);
gmModeColor := SEL(gmFamiArret,SEL(gmFamiFonct, gmColorDefail, gmColorFonct), gmColorArret);

UpdateSpeed();
//UpdateUi(pn:=pn);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateSpeed" Id="{294b2399-b561-4a6c-95ce-bc201f079bc3}">
      <Declaration><![CDATA[METHOD UpdateSpeed : BOOL

VAR
	factor : REAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Speed <= 0 THEN
	Speed := 1;
ELSIF Speed<>LastSpeed THEN
	LastSpeed := Speed; // sólo se ejecuta el código la primera vez que cambia la velocidad
	
	factor := 100.0/Speed;
	
	tmMaximoTiempoRespuesta		:= TO_TIME(TO_REAL(dt_MaximoTiempoRespuesta) * factor);
	tmTiempoReinicio			:= TO_TIME(TO_REAL(dt_TiempoReinicio) * factor);
	tmK_1 						:= TO_TIME(TO_REAL(dt_K_1) * factor);					// Temporizador empujador tapa
	tmR_1						:= TO_TIME(TO_REAL(dt_R_1) * factor);					// Temporizador retenedor de la cinta
	tmS_1						:= TO_TIME(TO_REAL(dt_S_1) * factor);					// Temporizador separador de la cinta
	tmEP						:= TO_TIME(TO_REAL(dt_EP) * factor);					// Tiempo de entrada del pale
	tmTP						:= TO_TIME(TO_REAL(dt_TP) * factor);					// Tiempo de transferencia del pale
	tmXP						:= TO_TIME(TO_REAL(dt_XP) * factor);					// Tiempo de salida del pale
	tmSOL 						:= TO_TIME(TO_REAL(dt_SOL) * factor); 					// tiempo después de soltar y antes de subir
	tmV_1						:= TO_TIME(TO_REAL(dt_V_1) * factor);					// tiempo máximo succionando sin que se active el sensor v1
	tmL_1						:= TO_TIME(TO_REAL(dt_L_1) * factor);					// tiempo máximo de bajada del medidor de tapas
	tmPIN 						:= TO_TIME(TO_REAL(dt_PIN) * factor);					// tiempo para pinzar una tapa antes de subir el brazo
	tmE_1						:= TO_TIME(TO_REAL(dt_E_1) * factor);					// tiempo para que el retenedor bloquee el plato
	tmD_1 						:= TO_TIME(TO_REAL(dt_D_1) * factor);					// tiempo para girar el plato a la siguiente posición
	
END_IF
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>